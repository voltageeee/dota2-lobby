// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_shared_enums.proto

#include "dota_shared_enums.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr CDOTAClientHardwareSpecs::CDOTAClientHardwareSpecs(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cpu_cycles_per_second_(PROTOBUF_ULONGLONG(0))
  , total_physical_memory_(PROTOBUF_ULONGLONG(0))
  , logical_processors_(0u)
  , is_64_bit_os_(false)
  , prefer_not_host_(false)
  , upload_measurement_(PROTOBUF_ULONGLONG(0)){}
struct CDOTAClientHardwareSpecsDefaultTypeInternal {
  constexpr CDOTAClientHardwareSpecsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDOTAClientHardwareSpecsDefaultTypeInternal() {}
  union {
    CDOTAClientHardwareSpecs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDOTAClientHardwareSpecsDefaultTypeInternal _CDOTAClientHardwareSpecs_default_instance_;
constexpr CDOTASaveGame_Player::CDOTASaveGame_Player(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hero_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , team_(0)
{}
struct CDOTASaveGame_PlayerDefaultTypeInternal {
  constexpr CDOTASaveGame_PlayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDOTASaveGame_PlayerDefaultTypeInternal() {}
  union {
    CDOTASaveGame_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDOTASaveGame_PlayerDefaultTypeInternal _CDOTASaveGame_Player_default_instance_;
constexpr CDOTASaveGame_SaveInstance_PlayerPositions::CDOTASaveGame_SaveInstance_PlayerPositions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0){}
struct CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal {
  constexpr CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal() {}
  union {
    CDOTASaveGame_SaveInstance_PlayerPositions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDOTASaveGame_SaveInstance_PlayerPositionsDefaultTypeInternal _CDOTASaveGame_SaveInstance_PlayerPositions_default_instance_;
constexpr CDOTASaveGame_SaveInstance::CDOTASaveGame_SaveInstance(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : player_positions_()
  , game_time_(0u)
  , team1_score_(0u)
  , team2_score_(0u)
  , save_id_(0u)
  , save_time_(0u){}
struct CDOTASaveGame_SaveInstanceDefaultTypeInternal {
  constexpr CDOTASaveGame_SaveInstanceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDOTASaveGame_SaveInstanceDefaultTypeInternal() {}
  union {
    CDOTASaveGame_SaveInstance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDOTASaveGame_SaveInstanceDefaultTypeInternal _CDOTASaveGame_SaveInstance_default_instance_;
constexpr CDOTASaveGame::CDOTASaveGame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : players_()
  , save_instances_()
  , match_id_(PROTOBUF_ULONGLONG(0))
  , save_time_(0u){}
struct CDOTASaveGameDefaultTypeInternal {
  constexpr CDOTASaveGameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDOTASaveGameDefaultTypeInternal() {}
  union {
    CDOTASaveGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDOTASaveGameDefaultTypeInternal _CDOTASaveGame_default_instance_;
constexpr CMsgDOTACombatLogEntry::CMsgDOTACombatLogEntry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : assist_players_()
  , target_name_(0u)
  , target_source_name_(0u)
  , attacker_name_(0u)
  , damage_source_name_(0u)
  , inflictor_name_(0u)
  , is_attacker_illusion_(false)
  , is_attacker_hero_(false)
  , is_target_illusion_(false)
  , is_target_hero_(false)
  , value_(0u)
  , health_(0)
  , timestamp_(0)
  , is_visible_radiant_(false)
  , is_visible_dire_(false)
  , is_ability_toggle_on_(false)
  , is_ability_toggle_off_(false)
  , stun_duration_(0)
  , slow_duration_(0)
  , ability_level_(0u)
  , location_x_(0)
  , location_y_(0)
  , gold_reason_(0u)
  , timestamp_raw_(0)
  , modifier_duration_(0)
  , xp_reason_(0u)
  , last_hits_(0u)
  , attacker_team_(0u)
  , target_team_(0u)
  , obs_wards_placed_(0u)
  , assist_player0_(0u)
  , assist_player1_(0u)
  , assist_player2_(0u)
  , assist_player3_(0u)
  , stack_count_(0u)
  , neutral_camp_type_(0u)
  , rune_type_(0u)
  , hidden_modifier_(false)
  , is_target_building_(false)
  , is_heal_save_(false)
  , is_ultimate_ability_(false)
  , attacker_hero_level_(0u)
  , target_hero_level_(0u)
  , xpm_(0u)
  , gpm_(0u)
  , event_location_(0u)
  , damage_type_(0u)
  , damage_category_(0u)
  , networth_(0u)
  , target_is_self_(false)
  , invisibility_modifier_(false)
  , silence_modifier_(false)
  , heal_from_lifesteal_(false)
  , building_type_(0u)
  , modifier_elapsed_duration_(0)
  , modifier_purged_(false)
  , spell_evaded_(false)
  , motion_controller_modifier_(false)
  , long_range_kill_(false)
  , modifier_purge_ability_(0u)
  , modifier_purge_npc_(0u)
  , total_unit_death_count_(0u)
  , root_modifier_(false)
  , aura_modifier_(false)
  , armor_debuff_modifier_(false)
  , no_physical_damage_modifier_(false)
  , modifier_ability_(0u)
  , kill_eater_event_(0u)
  , modifier_hidden_(false)
  , inflictor_is_stolen_ability_(false)
  , spell_generated_attack_(false)
  , at_night_time_(false)
  , unit_status_label_(0u)
  , attacker_has_scepter_(false)
  , type_(-1)
{}
struct CMsgDOTACombatLogEntryDefaultTypeInternal {
  constexpr CMsgDOTACombatLogEntryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgDOTACombatLogEntryDefaultTypeInternal() {}
  union {
    CMsgDOTACombatLogEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgDOTACombatLogEntryDefaultTypeInternal _CMsgDOTACombatLogEntry_default_instance_;
constexpr CMsgPendingEventAward::CMsgPendingEventAward(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : event_id_(0)

  , action_id_(0u)
  , num_to_grant_(0u)
  , score_mode_(0)

  , audit_action_(0u)
  , audit_data_(0u){}
struct CMsgPendingEventAwardDefaultTypeInternal {
  constexpr CMsgPendingEventAwardDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgPendingEventAwardDefaultTypeInternal() {}
  union {
    CMsgPendingEventAward _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgPendingEventAwardDefaultTypeInternal _CMsgPendingEventAward_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_dota_5fshared_5fenums_2eproto[7];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[46];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_dota_5fshared_5fenums_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_dota_5fshared_5fenums_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, logical_processors_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, cpu_cycles_per_second_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, total_physical_memory_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, is_64_bit_os_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, upload_measurement_),
  PROTOBUF_FIELD_OFFSET(::CDOTAClientHardwareSpecs, prefer_not_host_),
  2,
  0,
  1,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, team_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, name_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_Player, hero_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance_PlayerPositions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance_PlayerPositions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance_PlayerPositions, x_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance_PlayerPositions, y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, game_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, team1_score_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, team2_score_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, player_positions_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, save_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame_SaveInstance, save_time_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, match_id_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, save_time_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, players_),
  PROTOBUF_FIELD_OFFSET(::CDOTASaveGame, save_instances_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, target_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, target_source_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, attacker_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, damage_source_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, inflictor_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_attacker_illusion_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_attacker_hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_target_illusion_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_target_hero_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_visible_radiant_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_visible_dire_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, value_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, health_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, stun_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, slow_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_ability_toggle_on_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_ability_toggle_off_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, ability_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, location_x_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, location_y_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, gold_reason_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, timestamp_raw_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, modifier_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, xp_reason_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, last_hits_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, attacker_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, target_team_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, obs_wards_placed_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, assist_player0_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, assist_player1_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, assist_player2_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, assist_player3_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, stack_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, hidden_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_target_building_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, neutral_camp_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, rune_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, assist_players_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_heal_save_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, is_ultimate_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, attacker_hero_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, target_hero_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, xpm_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, gpm_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, event_location_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, target_is_self_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, damage_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, invisibility_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, damage_category_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, networth_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, building_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, modifier_elapsed_duration_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, silence_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, heal_from_lifesteal_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, modifier_purged_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, spell_evaded_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, motion_controller_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, long_range_kill_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, modifier_purge_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, modifier_purge_npc_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, root_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, total_unit_death_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, aura_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, armor_debuff_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, no_physical_damage_modifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, modifier_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, modifier_hidden_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, inflictor_is_stolen_ability_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, kill_eater_event_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, unit_status_label_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, spell_generated_attack_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, at_night_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgDOTACombatLogEntry, attacker_has_scepter_),
  73,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  12,
  13,
  9,
  10,
  11,
  16,
  17,
  14,
  15,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  36,
  37,
  34,
  35,
  ~0u,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  48,
  45,
  49,
  46,
  47,
  52,
  53,
  50,
  51,
  54,
  55,
  56,
  57,
  58,
  59,
  61,
  60,
  62,
  63,
  64,
  65,
  67,
  68,
  66,
  71,
  69,
  70,
  72,
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, event_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, action_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, num_to_grant_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, score_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, audit_action_),
  PROTOBUF_FIELD_OFFSET(::CMsgPendingEventAward, audit_data_),
  0,
  1,
  2,
  3,
  4,
  5,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, sizeof(::CDOTAClientHardwareSpecs)},
  { 17, 25, sizeof(::CDOTASaveGame_Player)},
  { 28, 35, sizeof(::CDOTASaveGame_SaveInstance_PlayerPositions)},
  { 37, 48, sizeof(::CDOTASaveGame_SaveInstance)},
  { 54, 63, sizeof(::CDOTASaveGame)},
  { 67, 147, sizeof(::CMsgDOTACombatLogEntry)},
  { 222, 233, sizeof(::CMsgPendingEventAward)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDOTAClientHardwareSpecs_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDOTASaveGame_Player_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDOTASaveGame_SaveInstance_PlayerPositions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDOTASaveGame_SaveInstance_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDOTASaveGame_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgDOTACombatLogEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgPendingEventAward_default_instance_),
};

const char descriptor_table_protodef_dota_5fshared_5fenums_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\027dota_shared_enums.proto\"\277\001\n\030CDOTAClien"
  "tHardwareSpecs\022\032\n\022logical_processors\030\001 \001"
  "(\r\022\035\n\025cpu_cycles_per_second\030\002 \001(\006\022\035\n\025tot"
  "al_physical_memory\030\003 \001(\006\022\024\n\014is_64_bit_os"
  "\030\004 \001(\010\022\032\n\022upload_measurement\030\005 \001(\004\022\027\n\017pr"
  "efer_not_host\030\006 \001(\010\"\316\003\n\rCDOTASaveGame\022\020\n"
  "\010match_id\030\005 \001(\004\022\021\n\tsave_time\030\002 \001(\r\022&\n\007pl"
  "ayers\030\003 \003(\0132\025.CDOTASaveGame.Player\0223\n\016sa"
  "ve_instances\030\004 \003(\0132\033.CDOTASaveGame.SaveI"
  "nstance\032Y\n\006Player\0223\n\004team\030\001 \001(\0162\r.DOTA_G"
  "C_TEAM:\026DOTA_GC_TEAM_GOOD_GUYS\022\014\n\004name\030\002"
  " \001(\t\022\014\n\004hero\030\003 \001(\t\032\337\001\n\014SaveInstance\022\021\n\tg"
  "ame_time\030\002 \001(\r\022\023\n\013team1_score\030\003 \001(\r\022\023\n\013t"
  "eam2_score\030\004 \001(\r\022E\n\020player_positions\030\005 \003"
  "(\0132+.CDOTASaveGame.SaveInstance.PlayerPo"
  "sitions\022\017\n\007save_id\030\006 \001(\r\022\021\n\tsave_time\030\007 "
  "\001(\r\032\'\n\017PlayerPositions\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002"
  " \001(\002\"\222\017\n\026CMsgDOTACombatLogEntry\022;\n\004type\030"
  "\001 \001(\0162\025.DOTA_COMBATLOG_TYPES:\026DOTA_COMBA"
  "TLOG_INVALID\022\023\n\013target_name\030\002 \001(\r\022\032\n\022tar"
  "get_source_name\030\003 \001(\r\022\025\n\rattacker_name\030\004"
  " \001(\r\022\032\n\022damage_source_name\030\005 \001(\r\022\026\n\016infl"
  "ictor_name\030\006 \001(\r\022\034\n\024is_attacker_illusion"
  "\030\007 \001(\010\022\030\n\020is_attacker_hero\030\010 \001(\010\022\032\n\022is_t"
  "arget_illusion\030\t \001(\010\022\026\n\016is_target_hero\030\n"
  " \001(\010\022\032\n\022is_visible_radiant\030\013 \001(\010\022\027\n\017is_v"
  "isible_dire\030\014 \001(\010\022\r\n\005value\030\r \001(\r\022\016\n\006heal"
  "th\030\016 \001(\005\022\021\n\ttimestamp\030\017 \001(\002\022\025\n\rstun_dura"
  "tion\030\020 \001(\002\022\025\n\rslow_duration\030\021 \001(\002\022\034\n\024is_"
  "ability_toggle_on\030\022 \001(\010\022\035\n\025is_ability_to"
  "ggle_off\030\023 \001(\010\022\025\n\rability_level\030\024 \001(\r\022\022\n"
  "\nlocation_x\030\025 \001(\002\022\022\n\nlocation_y\030\026 \001(\002\022\023\n"
  "\013gold_reason\030\027 \001(\r\022\025\n\rtimestamp_raw\030\030 \001("
  "\002\022\031\n\021modifier_duration\030\031 \001(\002\022\021\n\txp_reaso"
  "n\030\032 \001(\r\022\021\n\tlast_hits\030\033 \001(\r\022\025\n\rattacker_t"
  "eam\030\034 \001(\r\022\023\n\013target_team\030\035 \001(\r\022\030\n\020obs_wa"
  "rds_placed\030\036 \001(\r\022\026\n\016assist_player0\030\037 \001(\r"
  "\022\026\n\016assist_player1\030  \001(\r\022\026\n\016assist_playe"
  "r2\030! \001(\r\022\026\n\016assist_player3\030\" \001(\r\022\023\n\013stac"
  "k_count\030# \001(\r\022\027\n\017hidden_modifier\030$ \001(\010\022\032"
  "\n\022is_target_building\030% \001(\010\022\031\n\021neutral_ca"
  "mp_type\030& \001(\r\022\021\n\trune_type\030\' \001(\r\022\026\n\016assi"
  "st_players\030( \003(\r\022\024\n\014is_heal_save\030) \001(\010\022\033"
  "\n\023is_ultimate_ability\030* \001(\010\022\033\n\023attacker_"
  "hero_level\030+ \001(\r\022\031\n\021target_hero_level\030, "
  "\001(\r\022\013\n\003xpm\030- \001(\r\022\013\n\003gpm\030. \001(\r\022\026\n\016event_l"
  "ocation\030/ \001(\r\022\026\n\016target_is_self\0300 \001(\010\022\023\n"
  "\013damage_type\0301 \001(\r\022\035\n\025invisibility_modif"
  "ier\0302 \001(\010\022\027\n\017damage_category\0303 \001(\r\022\020\n\010ne"
  "tworth\0304 \001(\r\022\025\n\rbuilding_type\0305 \001(\r\022!\n\031m"
  "odifier_elapsed_duration\0306 \001(\002\022\030\n\020silenc"
  "e_modifier\0307 \001(\010\022\033\n\023heal_from_lifesteal\030"
  "8 \001(\010\022\027\n\017modifier_purged\0309 \001(\010\022\024\n\014spell_"
  "evaded\030: \001(\010\022\"\n\032motion_controller_modifi"
  "er\030; \001(\010\022\027\n\017long_range_kill\030< \001(\010\022\036\n\026mod"
  "ifier_purge_ability\030= \001(\r\022\032\n\022modifier_pu"
  "rge_npc\030> \001(\r\022\025\n\rroot_modifier\030\? \001(\010\022\036\n\026"
  "total_unit_death_count\030@ \001(\r\022\025\n\raura_mod"
  "ifier\030A \001(\010\022\035\n\025armor_debuff_modifier\030B \001"
  "(\010\022#\n\033no_physical_damage_modifier\030C \001(\010\022"
  "\030\n\020modifier_ability\030D \001(\r\022\027\n\017modifier_hi"
  "dden\030E \001(\010\022#\n\033inflictor_is_stolen_abilit"
  "y\030F \001(\010\022\030\n\020kill_eater_event\030G \001(\r\022\031\n\021uni"
  "t_status_label\030H \001(\r\022\036\n\026spell_generated_"
  "attack\030I \001(\010\022\025\n\rat_night_time\030J \001(\010\022\034\n\024a"
  "ttacker_has_scepter\030K \001(\010\"\335\001\n\025CMsgPendin"
  "gEventAward\022(\n\010event_id\030\001 \001(\0162\007.EEvent:\r"
  "EVENT_ID_NONE\022\021\n\taction_id\030\002 \001(\r\022\024\n\014num_"
  "to_grant\030\003 \001(\r\022G\n\nscore_mode\030\004 \001(\0162\026.EEv"
  "entActionScoreMode:\033k_eEventActionScoreM"
  "ode_Add\022\024\n\014audit_action\030\005 \001(\r\022\022\n\naudit_d"
  "ata\030\006 \001(\r*\232\005\n\rDOTA_GameMode\022\026\n\022DOTA_GAME"
  "MODE_NONE\020\000\022\024\n\020DOTA_GAMEMODE_AP\020\001\022\024\n\020DOT"
  "A_GAMEMODE_CM\020\002\022\024\n\020DOTA_GAMEMODE_RD\020\003\022\024\n"
  "\020DOTA_GAMEMODE_SD\020\004\022\024\n\020DOTA_GAMEMODE_AR\020"
  "\005\022\027\n\023DOTA_GAMEMODE_INTRO\020\006\022\024\n\020DOTA_GAMEM"
  "ODE_HW\020\007\022\034\n\030DOTA_GAMEMODE_REVERSE_CM\020\010\022\026"
  "\n\022DOTA_GAMEMODE_XMAS\020\t\022\032\n\026DOTA_GAMEMODE_"
  "TUTORIAL\020\n\022\024\n\020DOTA_GAMEMODE_MO\020\013\022\024\n\020DOTA"
  "_GAMEMODE_LP\020\014\022\027\n\023DOTA_GAMEMODE_POOL1\020\r\022"
  "\024\n\020DOTA_GAMEMODE_FH\020\016\022\030\n\024DOTA_GAMEMODE_C"
  "USTOM\020\017\022\024\n\020DOTA_GAMEMODE_CD\020\020\022\024\n\020DOTA_GA"
  "MEMODE_BD\020\021\022\037\n\033DOTA_GAMEMODE_ABILITY_DRA"
  "FT\020\022\022\027\n\023DOTA_GAMEMODE_EVENT\020\023\022\026\n\022DOTA_GA"
  "MEMODE_ARDM\020\024\022\030\n\024DOTA_GAMEMODE_1V1MID\020\025\022"
  "\033\n\027DOTA_GAMEMODE_ALL_DRAFT\020\026\022\027\n\023DOTA_GAM"
  "EMODE_TURBO\020\027\022\032\n\026DOTA_GAMEMODE_MUTATION\020"
  "\030\022#\n\037DOTA_GAMEMODE_COACHES_CHALLENGE\020\031*\225"
  "\004\n\016DOTA_GameState\022\035\n\031DOTA_GAMERULES_STAT"
  "E_INIT\020\000\0221\n-DOTA_GAMERULES_STATE_WAIT_FO"
  "R_PLAYERS_TO_LOAD\020\001\022\'\n#DOTA_GAMERULES_ST"
  "ATE_HERO_SELECTION\020\002\022&\n\"DOTA_GAMERULES_S"
  "TATE_STRATEGY_TIME\020\003\022!\n\035DOTA_GAMERULES_S"
  "TATE_PRE_GAME\020\004\022)\n%DOTA_GAMERULES_STATE_"
  "GAME_IN_PROGRESS\020\005\022\"\n\036DOTA_GAMERULES_STA"
  "TE_POST_GAME\020\006\022#\n\037DOTA_GAMERULES_STATE_D"
  "ISCONNECT\020\007\022&\n\"DOTA_GAMERULES_STATE_TEAM"
  "_SHOWCASE\020\010\022*\n&DOTA_GAMERULES_STATE_CUST"
  "OM_GAME_SETUP\020\t\022-\n)DOTA_GAMERULES_STATE_"
  "WAIT_FOR_MAP_TO_LOAD\020\n\022\'\n#DOTA_GAMERULES"
  "_STATE_SCENARIO_SETUP\020\013\022\035\n\031DOTA_GAMERULE"
  "S_STATE_LAST\020\014*\266\001\n\014DOTA_GC_TEAM\022\032\n\026DOTA_"
  "GC_TEAM_GOOD_GUYS\020\000\022\031\n\025DOTA_GC_TEAM_BAD_"
  "GUYS\020\001\022\034\n\030DOTA_GC_TEAM_BROADCASTER\020\002\022\032\n\026"
  "DOTA_GC_TEAM_SPECTATOR\020\003\022\034\n\030DOTA_GC_TEAM"
  "_PLAYER_POOL\020\004\022\027\n\023DOTA_GC_TEAM_NOTEAM\020\005*"
  "\205\010\n\006EEvent\022\021\n\rEVENT_ID_NONE\020\000\022\025\n\021EVENT_I"
  "D_DIRETIDE\020\001\022\034\n\030EVENT_ID_SPRING_FESTIVAL"
  "\020\002\022\033\n\027EVENT_ID_FROSTIVUS_2013\020\003\022\034\n\030EVENT"
  "_ID_COMPENDIUM_2014\020\004\022\032\n\026EVENT_ID_NEXON_"
  "PC_BANG\020\005\022\032\n\026EVENT_ID_PWRD_DAC_2015\020\006\022\033\n"
  "\027EVENT_ID_NEW_BLOOM_2015\020\007\022\037\n\033EVENT_ID_I"
  "NTERNATIONAL_2015\020\010\022\034\n\030EVENT_ID_FALL_MAJ"
  "OR_2015\020\t\022\026\n\022EVENT_ID_ORACLE_PA\020\n\022$\n EVE"
  "NT_ID_NEW_BLOOM_2015_PREBEAST\020\013\022\026\n\022EVENT"
  "_ID_FROSTIVUS\020\014\022\036\n\032EVENT_ID_WINTER_MAJOR"
  "_2016\020\r\022\037\n\033EVENT_ID_INTERNATIONAL_2016\020\016"
  "\022\034\n\030EVENT_ID_FALL_MAJOR_2016\020\017\022\036\n\032EVENT_"
  "ID_WINTER_MAJOR_2017\020\020\022\033\n\027EVENT_ID_NEW_B"
  "LOOM_2017\020\021\022\037\n\033EVENT_ID_INTERNATIONAL_20"
  "17\020\022\022\036\n\032EVENT_ID_PLUS_SUBSCRIPTION\020\023\022\035\n\031"
  "EVENT_ID_SINGLES_DAY_2017\020\024\022\033\n\027EVENT_ID_"
  "FROSTIVUS_2017\020\025\022\037\n\033EVENT_ID_INTERNATION"
  "AL_2018\020\026\022\033\n\027EVENT_ID_FROSTIVUS_2018\020\027\022\033"
  "\n\027EVENT_ID_NEW_BLOOM_2019\020\030\022\037\n\033EVENT_ID_"
  "INTERNATIONAL_2019\020\031\022\"\n\036EVENT_ID_NEW_PLA"
  "YER_EXPERIENCE\020\032\022\033\n\027EVENT_ID_FROSTIVUS_2"
  "019\020\033\022\033\n\027EVENT_ID_NEW_BLOOM_2020\020\034\022\037\n\033EV"
  "ENT_ID_INTERNATIONAL_2020\020\035\022\030\n\024EVENT_ID_"
  "TEAM_FANDOM\020\036\022\032\n\026EVENT_ID_DIRETIDE_2020\020"
  "\037\022\030\n\024EVENT_ID_SPRING_2021\020 \022\026\n\022EVENT_ID_"
  "FALL_2021\020!\022\022\n\016EVENT_ID_COUNT\020\"*\250\002\n\022DOTA"
  "LeaverStatus_t\022\024\n\020DOTA_LEAVER_NONE\020\000\022\034\n\030"
  "DOTA_LEAVER_DISCONNECTED\020\001\022%\n!DOTA_LEAVE"
  "R_DISCONNECTED_TOO_LONG\020\002\022\031\n\025DOTA_LEAVER"
  "_ABANDONED\020\003\022\023\n\017DOTA_LEAVER_AFK\020\004\022\037\n\033DOT"
  "A_LEAVER_NEVER_CONNECTED\020\005\022(\n$DOTA_LEAVE"
  "R_NEVER_CONNECTED_TOO_LONG\020\006\022\"\n\036DOTA_LEA"
  "VER_FAILED_TO_READY_UP\020\007\022\030\n\024DOTA_LEAVER_"
  "DECLINED\020\010*\236\002\n\025DOTAConnectionState_t\022!\n\035"
  "DOTA_CONNECTION_STATE_UNKNOWN\020\000\022+\n\'DOTA_"
  "CONNECTION_STATE_NOT_YET_CONNECTED\020\001\022#\n\037"
  "DOTA_CONNECTION_STATE_CONNECTED\020\002\022&\n\"DOT"
  "A_CONNECTION_STATE_DISCONNECTED\020\003\022#\n\037DOT"
  "A_CONNECTION_STATE_ABANDONED\020\004\022!\n\035DOTA_C"
  "ONNECTION_STATE_LOADING\020\005\022 \n\034DOTA_CONNEC"
  "TION_STATE_FAILED\020\006*\214\001\n\rFantasy_Roles\022\032\n"
  "\026FANTASY_ROLE_UNDEFINED\020\000\022\025\n\021FANTASY_ROL"
  "E_CORE\020\001\022\030\n\024FANTASY_ROLE_SUPPORT\020\002\022\030\n\024FA"
  "NTASY_ROLE_OFFLANE\020\003\022\024\n\020FANTASY_ROLE_MID"
  "\020\004*\212\001\n\022Fantasy_Team_Slots\022\025\n\021FANTASY_SLO"
  "T_NONE\020\000\022\025\n\021FANTASY_SLOT_CORE\020\001\022\030\n\024FANTA"
  "SY_SLOT_SUPPORT\020\002\022\024\n\020FANTASY_SLOT_ANY\020\003\022"
  "\026\n\022FANTASY_SLOT_BENCH\020\004*\335\002\n\026Fantasy_Sele"
  "ction_Mode\022\035\n\031FANTASY_SELECTION_INVALID\020"
  "\000\022\034\n\030FANTASY_SELECTION_LOCKED\020\001\022\035\n\031FANTA"
  "SY_SELECTION_SHUFFLE\020\002\022\037\n\033FANTASY_SELECT"
  "ION_FREE_PICK\020\003\022\033\n\027FANTASY_SELECTION_END"
  "ED\020\004\022 \n\034FANTASY_SELECTION_PRE_SEASON\020\005\022\037"
  "\n\033FANTASY_SELECTION_PRE_DRAFT\020\006\022\036\n\032FANTA"
  "SY_SELECTION_DRAFTING\020\007\022$\n FANTASY_SELEC"
  "TION_REGULAR_SEASON\020\010\022 \n\034FANTASY_SELECTI"
  "ON_CARD_BASED\020\t*\202\006\n\025DOTAChatChannelType_"
  "t\022\034\n\030DOTAChannelType_Regional\020\000\022\032\n\026DOTAC"
  "hannelType_Custom\020\001\022\031\n\025DOTAChannelType_P"
  "arty\020\002\022\031\n\025DOTAChannelType_Lobby\020\003\022\030\n\024DOT"
  "AChannelType_Team\020\004\022\031\n\025DOTAChannelType_G"
  "uild\020\005\022\033\n\027DOTAChannelType_Fantasy\020\006\022\033\n\027D"
  "OTAChannelType_Whisper\020\007\022\033\n\027DOTAChannelT"
  "ype_Console\020\010\022\027\n\023DOTAChannelType_Tab\020\t\022\033"
  "\n\027DOTAChannelType_Invalid\020\n\022\033\n\027DOTAChann"
  "elType_GameAll\020\013\022\036\n\032DOTAChannelType_Game"
  "Allies\020\014\022!\n\035DOTAChannelType_GameSpectato"
  "r\020\r\022 \n\034DOTAChannelType_GameCoaching\020\016\022\030\n"
  "\024DOTAChannelType_Cafe\020\017\022\036\n\032DOTAChannelTy"
  "pe_CustomGame\020\020\022\033\n\027DOTAChannelType_Priva"
  "te\020\021\022\034\n\030DOTAChannelType_PostGame\020\022\022\035\n\031DO"
  "TAChannelType_BattleCup\020\023\022!\n\035DOTAChannel"
  "Type_HLTVSpectator\020\024\022\036\n\032DOTAChannelType_"
  "GameEvents\020\025\022\032\n\026DOTAChannelType_Trivia\020\026"
  "\022\035\n\031DOTAChannelType_NewPlayer\020\027\022#\n\037DOTAC"
  "hannelType_PrivateCoaching\020\030*\220\001\n\026EChatSp"
  "ecialPrivileges\022!\n\035k_EChatSpecialPrivile"
  "ges_None\020\000\022&\n\"k_EChatSpecialPrivileges_M"
  "oderator\020\001\022+\n\'k_EChatSpecialPrivileges_S"
  "uperModerator\020\002*\204\002\n\024EProfileCardSlotType"
  "\022 \n\034k_EProfileCardSlotType_Empty\020\000\022\037\n\033k_"
  "EProfileCardSlotType_Stat\020\001\022!\n\035k_EProfil"
  "eCardSlotType_Trophy\020\002\022\037\n\033k_EProfileCard"
  "SlotType_Item\020\003\022\037\n\033k_EProfileCardSlotTyp"
  "e_Hero\020\004\022#\n\037k_EProfileCardSlotType_Emoti"
  "con\020\005\022\037\n\033k_EProfileCardSlotType_Team\020\006*\225"
  "\001\n\027EMatchGroupServerStatus\022 \n\034k_EMatchGr"
  "oupServerStatus_OK\020\000\0221\n-k_EMatchGroupSer"
  "verStatus_LimitedAvailability\020\001\022%\n!k_EMa"
  "tchGroupServerStatus_Offline\020\002*O\n\014DOTA_C"
  "M_PICK\022\022\n\016DOTA_CM_RANDOM\020\000\022\025\n\021DOTA_CM_GO"
  "OD_GUYS\020\001\022\024\n\020DOTA_CM_BAD_GUYS\020\002*\264\001\n\026DOTA"
  "LowPriorityBanType\022!\n\035DOTA_LOW_PRIORITY_"
  "BAN_ABANDON\020\000\022!\n\035DOTA_LOW_PRIORITY_BAN_R"
  "EPORTS\020\001\022+\n\'DOTA_LOW_PRIORITY_BAN_SECOND"
  "ARY_ABANDON\020\002\022\'\n#DOTA_LOW_PRIORITY_BAN_P"
  "RE_GAME_ROLE\020\003*}\n\023DOTALobbyReadyState\022\"\n"
  "\036DOTALobbyReadyState_UNDECLARED\020\000\022 \n\034DOT"
  "ALobbyReadyState_ACCEPTED\020\001\022 \n\034DOTALobby"
  "ReadyState_DECLINED\020\002*D\n\017DOTAGameVersion"
  "\022\030\n\024GAME_VERSION_CURRENT\020\000\022\027\n\023GAME_VERSI"
  "ON_STABLE\020\001*\272\004\n\023DOTAJoinLobbyResult\022\034\n\030D"
  "OTA_JOIN_RESULT_SUCCESS\020\000\022$\n DOTA_JOIN_R"
  "ESULT_ALREADY_IN_GAME\020\001\022\"\n\036DOTA_JOIN_RES"
  "ULT_INVALID_LOBBY\020\002\022\'\n#DOTA_JOIN_RESULT_"
  "INCORRECT_PASSWORD\020\003\022\"\n\036DOTA_JOIN_RESULT"
  "_ACCESS_DENIED\020\004\022\"\n\036DOTA_JOIN_RESULT_GEN"
  "ERIC_ERROR\020\005\022&\n\"DOTA_JOIN_RESULT_INCORRE"
  "CT_VERSION\020\006\022\"\n\036DOTA_JOIN_RESULT_IN_TEAM"
  "_PARTY\020\007\022#\n\037DOTA_JOIN_RESULT_NO_LOBBY_FO"
  "UND\020\010\022\037\n\033DOTA_JOIN_RESULT_LOBBY_FULL\020\t\0222"
  "\n.DOTA_JOIN_RESULT_CUSTOM_GAME_INCORRECT"
  "_VERSION\020\n\022\034\n\030DOTA_JOIN_RESULT_TIMEOUT\020\013"
  "\022)\n%DOTA_JOIN_RESULT_CUSTOM_GAME_COOLDOW"
  "N\020\014\022\031\n\025DOTA_JOIN_RESULT_BUSY\020\r\022 \n\034DOTA_J"
  "OIN_RESULT_NO_PLAYTIME\020\016*q\n\032DOTASelectio"
  "nPriorityRules\022\'\n#k_DOTASelectionPriorit"
  "yRules_Manual\020\000\022*\n&k_DOTASelectionPriori"
  "tyRules_Automatic\020\001*\366\001\n\033DOTASelectionPri"
  "orityChoice\022)\n%k_DOTASelectionPriorityCh"
  "oice_Invalid\020\000\022+\n\'k_DOTASelectionPriorit"
  "yChoice_FirstPick\020\001\022,\n(k_DOTASelectionPr"
  "iorityChoice_SecondPick\020\002\022)\n%k_DOTASelec"
  "tionPriorityChoice_Radiant\020\003\022&\n\"k_DOTASe"
  "lectionPriorityChoice_Dire\020\004*b\n\rDOTAMatc"
  "hVote\022\031\n\025DOTAMatchVote_INVALID\020\000\022\032\n\026DOTA"
  "MatchVote_POSITIVE\020\001\022\032\n\026DOTAMatchVote_NE"
  "GATIVE\020\002*x\n\023DOTALobbyVisibility\022\036\n\032DOTAL"
  "obbyVisibility_Public\020\000\022\037\n\033DOTALobbyVisi"
  "bility_Friends\020\001\022 \n\034DOTALobbyVisibility_"
  "Unlisted\020\002*\351\001\n\022EDOTAPlayerMMRType\022 \n\034k_E"
  "DOTAPlayerMMRType_Invalid\020\000\022&\n\"k_EDOTAPl"
  "ayerMMRType_GeneralHidden\020\001\022+\n\'k_EDOTAPl"
  "ayerMMRType_GeneralCompetitive\020\003\022,\n(k_ED"
  "OTAPlayerMMRType_SoloCompetitive2019\020\004\022."
  "\n*k_EDOTAPlayerMMRType_1v1Competitive_UN"
  "USED\020\005*s\n\021EDOTAMMRBoostType\022\034\n\030k_EDOTAMM"
  "RBoostType_None\020\000\022\036\n\032k_EDOTAMMRBoostType"
  "_Leader\020\001\022 \n\034k_EDOTAMMRBoostType_Followe"
  "r\020\002*\300\003\n\tMatchType\022\025\n\021MATCH_TYPE_CASUAL\020\000"
  "\022\030\n\024MATCH_TYPE_COOP_BOTS\020\001\022!\n\035MATCH_TYPE"
  "_LEGACY_TEAM_RANKED\020\002\022 \n\034MATCH_TYPE_LEGA"
  "CY_SOLO_QUEUE\020\003\022\032\n\026MATCH_TYPE_COMPETITIV"
  "E\020\004\022\036\n\032MATCH_TYPE_WEEKEND_TOURNEY\020\005\022\031\n\025M"
  "ATCH_TYPE_CASUAL_1V1\020\006\022\024\n\020MATCH_TYPE_EVE"
  "NT\020\007\022\036\n\032MATCH_TYPE_SEASONAL_RANKED\020\010\022 \n\034"
  "MATCH_TYPE_LOWPRI_DEPRECATED\020\t\022\032\n\026MATCH_"
  "TYPE_STEAM_GROUP\020\n\022\027\n\023MATCH_TYPE_MUTATIO"
  "N\020\013\022 \n\034MATCH_TYPE_COACHES_CHALLENGE\020\014\022\027\n"
  "\023MATCH_TYPE_GAUNTLET\020\r\022\036\n\032MATCH_TYPE_NEW"
  "_PLAYER_POOL\020\016*\234\002\n\021DOTABotDifficulty\022\032\n\026"
  "BOT_DIFFICULTY_PASSIVE\020\000\022\027\n\023BOT_DIFFICUL"
  "TY_EASY\020\001\022\031\n\025BOT_DIFFICULTY_MEDIUM\020\002\022\027\n\023"
  "BOT_DIFFICULTY_HARD\020\003\022\031\n\025BOT_DIFFICULTY_"
  "UNFAIR\020\004\022\032\n\026BOT_DIFFICULTY_INVALID\020\005\022\031\n\025"
  "BOT_DIFFICULTY_EXTRA1\020\006\022\031\n\025BOT_DIFFICULT"
  "Y_EXTRA2\020\007\022\031\n\025BOT_DIFFICULTY_EXTRA3\020\010\022\026\n"
  "\022BOT_DIFFICULTY_NPX\020\t*\256\006\n\rDOTA_BOT_MODE\022"
  "\026\n\022DOTA_BOT_MODE_NONE\020\000\022\030\n\024DOTA_BOT_MODE"
  "_LANING\020\001\022\030\n\024DOTA_BOT_MODE_ATTACK\020\002\022\026\n\022D"
  "OTA_BOT_MODE_ROAM\020\003\022\031\n\025DOTA_BOT_MODE_RET"
  "REAT\020\004\022\035\n\031DOTA_BOT_MODE_SECRET_SHOP\020\005\022\033\n"
  "\027DOTA_BOT_MODE_SIDE_SHOP\020\006\022\026\n\022DOTA_BOT_M"
  "ODE_RUNE\020\007\022 \n\034DOTA_BOT_MODE_PUSH_TOWER_T"
  "OP\020\010\022 \n\034DOTA_BOT_MODE_PUSH_TOWER_MID\020\t\022 "
  "\n\034DOTA_BOT_MODE_PUSH_TOWER_BOT\020\n\022\"\n\036DOTA"
  "_BOT_MODE_DEFEND_TOWER_TOP\020\013\022\"\n\036DOTA_BOT"
  "_MODE_DEFEND_TOWER_MID\020\014\022\"\n\036DOTA_BOT_MOD"
  "E_DEFEND_TOWER_BOT\020\r\022\032\n\026DOTA_BOT_MODE_AS"
  "SEMBLE\020\016\022&\n\"DOTA_BOT_MODE_ASSEMBLE_WITH_"
  "HUMANS\020\017\022\033\n\027DOTA_BOT_MODE_TEAM_ROAM\020\020\022\026\n"
  "\022DOTA_BOT_MODE_FARM\020\021\022\035\n\031DOTA_BOT_MODE_D"
  "EFEND_ALLY\020\022\022#\n\037DOTA_BOT_MODE_EVASIVE_MA"
  "NEUVERS\020\023\022\030\n\024DOTA_BOT_MODE_ROSHAN\020\024\022\026\n\022D"
  "OTA_BOT_MODE_ITEM\020\025\022\026\n\022DOTA_BOT_MODE_WAR"
  "D\020\026\022\033\n\027DOTA_BOT_MODE_COMPANION\020\027\022\037\n\033DOTA"
  "_BOT_MODE_TUTORIAL_BOSS\020\030\022\030\n\024DOTA_BOT_MO"
  "DE_MINION\020\031\022\031\n\025DOTA_BOT_MODE_OUTPOST\020\032*\363"
  "\001\n\016MatchLanguages\022\032\n\026MATCH_LANGUAGE_INVA"
  "LID\020\000\022\032\n\026MATCH_LANGUAGE_ENGLISH\020\001\022\032\n\026MAT"
  "CH_LANGUAGE_RUSSIAN\020\002\022\032\n\026MATCH_LANGUAGE_"
  "CHINESE\020\003\022\031\n\025MATCH_LANGUAGE_KOREAN\020\004\022\032\n\026"
  "MATCH_LANGUAGE_SPANISH\020\005\022\035\n\031MATCH_LANGUA"
  "GE_PORTUGUESE\020\006\022\033\n\027MATCH_LANGUAGE_ENGLIS"
  "H2\020\007*\330\002\n\032ETourneyQueueDeadlineState\022\'\n#k"
  "_ETourneyQueueDeadlineState_Normal\020\000\022\'\n#"
  "k_ETourneyQueueDeadlineState_Missed\020\001\022*\n"
  "&k_ETourneyQueueDeadlineState_ExpiredOK\020"
  "\002\022+\n\'k_ETourneyQueueDeadlineState_Seekin"
  "gBye\020\003\0222\n.k_ETourneyQueueDeadlineState_E"
  "ligibleForRefund\020\004\022,\n\037k_ETourneyQueueDea"
  "dlineState_NA\020\377\377\377\377\377\377\377\377\377\001\022-\n)k_ETourneyQu"
  "eueDeadlineState_ExpiringSoon\020e*\361\002\n\rEMat"
  "chOutcome\022\033\n\027k_EMatchOutcome_Unknown\020\000\022\036"
  "\n\032k_EMatchOutcome_RadVictory\020\002\022\037\n\033k_EMat"
  "chOutcome_DireVictory\020\003\0223\n/k_EMatchOutco"
  "me_NotScored_PoorNetworkConditions\020@\022$\n "
  "k_EMatchOutcome_NotScored_Leaver\020A\022)\n%k_"
  "EMatchOutcome_NotScored_ServerCrash\020B\022*\n"
  "&k_EMatchOutcome_NotScored_NeverStarted\020"
  "C\022&\n\"k_EMatchOutcome_NotScored_Canceled\020"
  "D\022(\n$k_EMatchOutcome_NotScored_Suspiciou"
  "s\020E*\206\001\n\tELaneType\022\025\n\021LANE_TYPE_UNKNOWN\020\000"
  "\022\022\n\016LANE_TYPE_SAFE\020\001\022\021\n\rLANE_TYPE_OFF\020\002\022"
  "\021\n\rLANE_TYPE_MID\020\003\022\024\n\020LANE_TYPE_JUNGLE\020\004"
  "\022\022\n\016LANE_TYPE_ROAM\020\005*\327\001\n\nEBadgeType\022\034\n\030k"
  "_EBadgeType_TI7_Midweek\020\001\022\033\n\027k_EBadgeTyp"
  "e_TI7_Finals\020\002\022\035\n\031k_EBadgeType_TI7_AllEv"
  "ent\020\003\022\034\n\030k_EBadgeType_TI8_Midweek\020\004\022\033\n\027k"
  "_EBadgeType_TI8_Finals\020\005\022\035\n\031k_EBadgeType"
  "_TI8_AllEvent\020\006\022\025\n\021k_EBadgeType_TI10\020\007*\324"
  "\001\n\rELeagueStatus\022\027\n\023LEAGUE_STATUS_UNSET\020"
  "\000\022\035\n\031LEAGUE_STATUS_UNSUBMITTED\020\001\022\033\n\027LEAG"
  "UE_STATUS_SUBMITTED\020\002\022\032\n\026LEAGUE_STATUS_A"
  "CCEPTED\020\003\022\032\n\026LEAGUE_STATUS_REJECTED\020\004\022\033\n"
  "\027LEAGUE_STATUS_CONCLUDED\020\005\022\031\n\025LEAGUE_STA"
  "TUS_DELETED\020\006*\265\001\n\rELeagueRegion\022\027\n\023LEAGU"
  "E_REGION_UNSET\020\000\022\024\n\020LEAGUE_REGION_NA\020\001\022\024"
  "\n\020LEAGUE_REGION_SA\020\002\022\030\n\024LEAGUE_REGION_EU"
  "ROPE\020\003\022\025\n\021LEAGUE_REGION_CIS\020\004\022\027\n\023LEAGUE_"
  "REGION_CHINA\020\005\022\025\n\021LEAGUE_REGION_SEA\020\006*\211\002"
  "\n\013ELeagueTier\022\025\n\021LEAGUE_TIER_UNSET\020\000\022\027\n\023"
  "LEAGUE_TIER_AMATEUR\020\001\022\034\n\030LEAGUE_TIER_PRO"
  "FESSIONAL\020\002\022\025\n\021LEAGUE_TIER_MINOR\020\003\022\025\n\021LE"
  "AGUE_TIER_MAJOR\020\004\022\035\n\031LEAGUE_TIER_INTERNA"
  "TIONAL\020\005\022\035\n\031LEAGUE_TIER_DPC_QUALIFIER\020\006\022"
  "$\n LEAGUE_TIER_DPC_LEAGUE_QUALIFIER\020\007\022\032\n"
  "\026LEAGUE_TIER_DPC_LEAGUE\020\010*|\n\023ELeagueTier"
  "Category\022 \n\034LEAGUE_TIER_CATEGORY_AMATEUR"
  "\020\001\022%\n!LEAGUE_TIER_CATEGORY_PROFESSIONAL\020"
  "\002\022\034\n\030LEAGUE_TIER_CATEGORY_DPC\020\003*\240\001\n\014ELea"
  "gueFlags\022\025\n\021LEAGUE_FLAGS_NONE\020\000\022\035\n\031LEAGU"
  "E_ACCEPTED_AGREEMENT\020\001\022\035\n\031LEAGUE_PAYMENT"
  "_EMAIL_SENT\020\002\022\035\n\031LEAGUE_COMPENDIUM_ALLOW"
  "ED\020\004\022\034\n\030LEAGUE_COMPENDIUM_PUBLIC\020\010*\253\001\n\030E"
  "LeagueBroadcastProvider\022\034\n\030LEAGUE_BROADC"
  "AST_UNKNOWN\020\000\022\032\n\026LEAGUE_BROADCAST_STEAM\020"
  "\001\022\033\n\027LEAGUE_BROADCAST_TWITCH\020\002\022\034\n\030LEAGUE"
  "_BROADCAST_YOUTUBE\020\003\022\032\n\026LEAGUE_BROADCAST"
  "_OTHER\020d*\206\001\n\014ELeaguePhase\022\026\n\022LEAGUE_PHAS"
  "E_UNSET\020\000\022#\n\037LEAGUE_PHASE_REGIONAL_QUALI"
  "FIER\020\001\022\034\n\030LEAGUE_PHASE_GROUP_STAGE\020\002\022\033\n\027"
  "LEAGUE_PHASE_MAIN_EVENT\020\003*\332\016\n\022ELeagueAud"
  "itAction\022\037\n\033LEAGUE_AUDIT_ACTION_INVALID\020"
  "\000\022%\n!LEAGUE_AUDIT_ACTION_LEAGUE_CREATE\020\001"
  "\022#\n\037LEAGUE_AUDIT_ACTION_LEAGUE_EDIT\020\002\022%\n"
  "!LEAGUE_AUDIT_ACTION_LEAGUE_DELETE\020\003\022(\n$"
  "LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_ADD\020\004\022+"
  "\n\'LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_REVOK"
  "E\020\005\022,\n(LEAGUE_AUDIT_ACTION_LEAGUE_ADMIN_"
  "PROMOTE\020\006\022)\n%LEAGUE_AUDIT_ACTION_LEAGUE_"
  "STREAM_ADD\020\007\022,\n(LEAGUE_AUDIT_ACTION_LEAG"
  "UE_STREAM_REMOVE\020\010\022,\n(LEAGUE_AUDIT_ACTIO"
  "N_LEAGUE_IMAGE_UPDATED\020\t\022,\n(LEAGUE_AUDIT"
  "_ACTION_LEAGUE_MESSAGE_ADDED\020\n\022(\n$LEAGUE"
  "_AUDIT_ACTION_LEAGUE_SUBMITTED\020\013\022-\n)LEAG"
  "UE_AUDIT_ACTION_LEAGUE_SET_PRIZE_POOL\020\014\022"
  "2\n.LEAGUE_AUDIT_ACTION_LEAGUE_ADD_PRIZE_"
  "POOL_ITEM\020\r\0225\n1LEAGUE_AUDIT_ACTION_LEAGU"
  "E_REMOVE_PRIZE_POOL_ITEM\020\016\022*\n&LEAGUE_AUD"
  "IT_ACTION_LEAGUE_MATCH_START\020\017\022(\n$LEAGUE"
  "_AUDIT_ACTION_LEAGUE_MATCH_END\020\020\022/\n+LEAG"
  "UE_AUDIT_ACTION_LEAGUE_ADD_INVITED_TEAM\020"
  "\021\0222\n.LEAGUE_AUDIT_ACTION_LEAGUE_REMOVE_I"
  "NVITED_TEAM\020\022\022-\n)LEAGUE_AUDIT_ACTION_LEA"
  "GUE_STATUS_CHANGED\020\023\022*\n&LEAGUE_AUDIT_ACT"
  "ION_LEAGUE_STREAM_EDIT\020\024\022(\n$LEAGUE_AUDIT"
  "_ACTION_LEAGUE_TEAM_SWAP\020\025\022(\n$LEAGUE_AUD"
  "IT_ACTION_NODEGROUP_CREATE\020d\022)\n%LEAGUE_A"
  "UDIT_ACTION_NODEGROUP_DESTROY\020e\022*\n&LEAGU"
  "E_AUDIT_ACTION_NODEGROUP_ADD_TEAM\020f\022-\n)L"
  "EAGUE_AUDIT_ACTION_NODEGROUP_REMOVE_TEAM"
  "\020g\022/\n+LEAGUE_AUDIT_ACTION_NODEGROUP_SET_"
  "ADVANCING\020h\022&\n\"LEAGUE_AUDIT_ACTION_NODEG"
  "ROUP_EDIT\020i\022*\n&LEAGUE_AUDIT_ACTION_NODEG"
  "ROUP_POPULATE\020j\022+\n\'LEAGUE_AUDIT_ACTION_N"
  "ODEGROUP_COMPLETED\020k\0229\n5LEAGUE_AUDIT_ACT"
  "ION_NODEGROUP_SET_SECONDARY_ADVANCING\020l\022"
  "8\n4LEAGUE_AUDIT_ACTION_NODEGROUP_SET_TER"
  "TIARY_ADVANCING\020m\022$\n\037LEAGUE_AUDIT_ACTION"
  "_NODE_CREATE\020\310\001\022%\n LEAGUE_AUDIT_ACTION_N"
  "ODE_DESTROY\020\311\001\022(\n#LEAGUE_AUDIT_ACTION_NO"
  "DE_AUTOCREATE\020\312\001\022&\n!LEAGUE_AUDIT_ACTION_"
  "NODE_SET_TEAM\020\313\001\022+\n&LEAGUE_AUDIT_ACTION_"
  "NODE_SET_SERIES_ID\020\314\001\022+\n&LEAGUE_AUDIT_AC"
  "TION_NODE_SET_ADVANCING\020\315\001\022&\n!LEAGUE_AUD"
  "IT_ACTION_NODE_SET_TIME\020\316\001\022-\n(LEAGUE_AUD"
  "IT_ACTION_NODE_MATCH_COMPLETED\020\317\001\022\'\n\"LEA"
  "GUE_AUDIT_ACTION_NODE_COMPLETED\020\320\001\022\"\n\035LE"
  "AGUE_AUDIT_ACTION_NODE_EDIT\020\321\001*\277\013\n\024DOTA_"
  "COMBATLOG_TYPES\022#\n\026DOTA_COMBATLOG_INVALI"
  "D\020\377\377\377\377\377\377\377\377\377\001\022\031\n\025DOTA_COMBATLOG_DAMAGE\020\000\022"
  "\027\n\023DOTA_COMBATLOG_HEAL\020\001\022\037\n\033DOTA_COMBATL"
  "OG_MODIFIER_ADD\020\002\022\"\n\036DOTA_COMBATLOG_MODI"
  "FIER_REMOVE\020\003\022\030\n\024DOTA_COMBATLOG_DEATH\020\004\022"
  "\032\n\026DOTA_COMBATLOG_ABILITY\020\005\022\027\n\023DOTA_COMB"
  "ATLOG_ITEM\020\006\022\033\n\027DOTA_COMBATLOG_LOCATION\020"
  "\007\022\027\n\023DOTA_COMBATLOG_GOLD\020\010\022\035\n\031DOTA_COMBA"
  "TLOG_GAME_STATE\020\t\022\025\n\021DOTA_COMBATLOG_XP\020\n"
  "\022\033\n\027DOTA_COMBATLOG_PURCHASE\020\013\022\032\n\026DOTA_CO"
  "MBATLOG_BUYBACK\020\014\022\"\n\036DOTA_COMBATLOG_ABIL"
  "ITY_TRIGGER\020\r\022\036\n\032DOTA_COMBATLOG_PLAYERST"
  "ATS\020\016\022\034\n\030DOTA_COMBATLOG_MULTIKILL\020\017\022\035\n\031D"
  "OTA_COMBATLOG_KILLSTREAK\020\020\022%\n!DOTA_COMBA"
  "TLOG_TEAM_BUILDING_KILL\020\021\022\036\n\032DOTA_COMBAT"
  "LOG_FIRST_BLOOD\020\022\022\'\n#DOTA_COMBATLOG_MODI"
  "FIER_STACK_EVENT\020\023\022%\n!DOTA_COMBATLOG_NEU"
  "TRAL_CAMP_STACK\020\024\022\036\n\032DOTA_COMBATLOG_PICK"
  "UP_RUNE\020\025\022%\n!DOTA_COMBATLOG_REVEALED_INV"
  "ISIBLE\020\026\022\035\n\031DOTA_COMBATLOG_HERO_SAVED\020\027\022"
  " \n\034DOTA_COMBATLOG_MANA_RESTORED\020\030\022\037\n\033DOT"
  "A_COMBATLOG_HERO_LEVELUP\020\031\022#\n\037DOTA_COMBA"
  "TLOG_BOTTLE_HEAL_ALLY\020\032\022 \n\034DOTA_COMBATLO"
  "G_ENDGAME_STATS\020\033\022$\n DOTA_COMBATLOG_INTE"
  "RRUPT_CHANNEL\020\034\022\036\n\032DOTA_COMBATLOG_ALLIED"
  "_GOLD\020\035\022\036\n\032DOTA_COMBATLOG_AEGIS_TAKEN\020\036\022"
  "\036\n\032DOTA_COMBATLOG_MANA_DAMAGE\020\037\022,\n(DOTA_"
  "COMBATLOG_PHYSICAL_DAMAGE_PREVENTED\020 \022 \n"
  "\034DOTA_COMBATLOG_UNIT_SUMMONED\020!\022\037\n\033DOTA_"
  "COMBATLOG_ATTACK_EVADE\020\"\022\033\n\027DOTA_COMBATL"
  "OG_TREE_CUT\020#\022\"\n\036DOTA_COMBATLOG_SUCCESSF"
  "UL_SCAN\020$\022!\n\035DOTA_COMBATLOG_END_KILLSTRE"
  "AK\020%\022$\n DOTA_COMBATLOG_BLOODSTONE_CHARGE"
  "\020&\022\"\n\036DOTA_COMBATLOG_CRITICAL_DAMAGE\020\'\022\037"
  "\n\033DOTA_COMBATLOG_SPELL_ABSORB\020(\022\"\n\036DOTA_"
  "COMBATLOG_UNIT_TELEPORTED\020)\022#\n\037DOTA_COMB"
  "ATLOG_KILL_EATER_EVENT\020**u\n\020EDPCFavorite"
  "Type\022\025\n\021FAVORITE_TYPE_ALL\020\000\022\030\n\024FAVORITE_"
  "TYPE_PLAYER\020\001\022\026\n\022FAVORITE_TYPE_TEAM\020\002\022\030\n"
  "\024FAVORITE_TYPE_LEAGUE\020\003*\250\004\n\024EDPCPushNoti"
  "fication\022(\n$DPC_PUSH_NOTIFICATION_MATCH_"
  "STARTING\020\001\022*\n&DPC_PUSH_NOTIFICATION_PLAY"
  "ER_LEFT_TEAM\020\n\022,\n(DPC_PUSH_NOTIFICATION_"
  "PLAYER_JOINED_TEAM\020\013\0225\n1DPC_PUSH_NOTIFIC"
  "ATION_PLAYER_JOINED_TEAM_AS_COACH\020\014\0223\n/D"
  "PC_PUSH_NOTIFICATION_PLAYER_LEFT_TEAM_AS"
  "_COACH\020\r\022\'\n#DPC_PUSH_NOTIFICATION_LEAGUE"
  "_RESULT\020\024\0226\n2DPC_PUSH_NOTIFICATION_PREDI"
  "CTION_MATCHES_AVAILABLE\020\036\022+\n\'DPC_PUSH_NO"
  "TIFICATION_PREDICTION_RESULT\020\037\0220\n,DPC_PU"
  "SH_NOTIFICATION_FANTASY_PLAYER_CLEARED\020("
  "\022/\n+DPC_PUSH_NOTIFICATION_FANTASY_DAILY_"
  "SUMMARY\020)\022/\n+DPC_PUSH_NOTIFICATION_FANTA"
  "SY_FINAL_RESULTS\020**Y\n\025EEventActionScoreM"
  "ode\022\037\n\033k_eEventActionScoreMode_Add\020\000\022\037\n\033"
  "k_eEventActionScoreMode_Min\020\001*\316\002\n\033EPlaye"
  "rChallengeHistoryType\022)\n%k_EPlayerChalle"
  "ngeHistoryType_Invalid\020\000\022+\n\'k_EPlayerCha"
  "llengeHistoryType_KillEater\020\001\022/\n+k_EPlay"
  "erChallengeHistoryType_DotaPlusRelic\020\002\022="
  "\n9k_EPlayerChallengeHistoryType_DotaPlus"
  "HeroPlayerChallenge\020\003\0226\n2k_EPlayerChalle"
  "ngeHistoryType_InGameEventChallenge\020\004\022/\n"
  "+k_EPlayerChallengeHistoryType_GuildCont"
  "ract\020\005*\206\002\n\026EOverwatchReportReason\022$\n k_E"
  "OverwatchReportReason_Unknown\020\000\022%\n!k_EOv"
  "erwatchReportReason_Cheating\020\001\022$\n k_EOve"
  "rwatchReportReason_Feeding\020\002\022%\n!k_EOverw"
  "atchReportReason_Griefing\020\003\022\'\n#k_EOverwa"
  "tchReportReason_Suspicious\020\004\022)\n%k_EOverw"
  "atchReportReason_AbilityAbuse\020\005B\005H\001\200\001\000"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_dota_5fshared_5fenums_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dota_5fshared_5fenums_2eproto = {
  false, false, 18678, descriptor_table_protodef_dota_5fshared_5fenums_2eproto, "dota_shared_enums.proto", 
  &descriptor_table_dota_5fshared_5fenums_2eproto_once, nullptr, 0, 7,
  schemas, file_default_instances, TableStruct_dota_5fshared_5fenums_2eproto::offsets,
  file_level_metadata_dota_5fshared_5fenums_2eproto, file_level_enum_descriptors_dota_5fshared_5fenums_2eproto, file_level_service_descriptors_dota_5fshared_5fenums_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK ::PROTOBUF_NAMESPACE_ID::Metadata
descriptor_table_dota_5fshared_5fenums_2eproto_metadata_getter(int index) {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return descriptor_table_dota_5fshared_5fenums_2eproto.file_level_metadata[index];
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_dota_5fshared_5fenums_2eproto(&descriptor_table_dota_5fshared_5fenums_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GameMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[0];
}
bool DOTA_GameMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GameState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[1];
}
bool DOTA_GameState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_GC_TEAM_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[2];
}
bool DOTA_GC_TEAM_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[3];
}
bool EEvent_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALeaverStatus_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[4];
}
bool DOTALeaverStatus_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAConnectionState_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[5];
}
bool DOTAConnectionState_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Roles_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[6];
}
bool Fantasy_Roles_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Team_Slots_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[7];
}
bool Fantasy_Team_Slots_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fantasy_Selection_Mode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[8];
}
bool Fantasy_Selection_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAChatChannelType_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[9];
}
bool DOTAChatChannelType_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EChatSpecialPrivileges_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[10];
}
bool EChatSpecialPrivileges_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EProfileCardSlotType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[11];
}
bool EProfileCardSlotType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMatchGroupServerStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[12];
}
bool EMatchGroupServerStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_CM_PICK_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[13];
}
bool DOTA_CM_PICK_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALowPriorityBanType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[14];
}
bool DOTALowPriorityBanType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALobbyReadyState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[15];
}
bool DOTALobbyReadyState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAGameVersion_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[16];
}
bool DOTAGameVersion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAJoinLobbyResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[17];
}
bool DOTAJoinLobbyResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTASelectionPriorityRules_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[18];
}
bool DOTASelectionPriorityRules_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTASelectionPriorityChoice_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[19];
}
bool DOTASelectionPriorityChoice_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTAMatchVote_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[20];
}
bool DOTAMatchVote_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTALobbyVisibility_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[21];
}
bool DOTALobbyVisibility_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDOTAPlayerMMRType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[22];
}
bool EDOTAPlayerMMRType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDOTAMMRBoostType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[23];
}
bool EDOTAMMRBoostType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[24];
}
bool MatchType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTABotDifficulty_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[25];
}
bool DOTABotDifficulty_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_BOT_MODE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[26];
}
bool DOTA_BOT_MODE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchLanguages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[27];
}
bool MatchLanguages_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETourneyQueueDeadlineState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[28];
}
bool ETourneyQueueDeadlineState_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 101:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMatchOutcome_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[29];
}
bool EMatchOutcome_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELaneType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[30];
}
bool ELaneType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBadgeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[31];
}
bool EBadgeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[32];
}
bool ELeagueStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueRegion_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[33];
}
bool ELeagueRegion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueTier_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[34];
}
bool ELeagueTier_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueTierCategory_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[35];
}
bool ELeagueTierCategory_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueFlags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[36];
}
bool ELeagueFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueBroadcastProvider_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[37];
}
bool ELeagueBroadcastProvider_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 100:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeaguePhase_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[38];
}
bool ELeaguePhase_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeagueAuditAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[39];
}
bool ELeagueAuditAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DOTA_COMBATLOG_TYPES_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[40];
}
bool DOTA_COMBATLOG_TYPES_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDPCFavoriteType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[41];
}
bool EDPCFavoriteType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDPCPushNotification_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[42];
}
bool EDPCPushNotification_IsValid(int value) {
  switch (value) {
    case 1:
    case 10:
    case 11:
    case 12:
    case 13:
    case 20:
    case 30:
    case 31:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEventActionScoreMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[43];
}
bool EEventActionScoreMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPlayerChallengeHistoryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[44];
}
bool EPlayerChallengeHistoryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOverwatchReportReason_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fshared_5fenums_2eproto);
  return file_level_enum_descriptors_dota_5fshared_5fenums_2eproto[45];
}
bool EOverwatchReportReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CDOTAClientHardwareSpecs::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTAClientHardwareSpecs>()._has_bits_);
  static void set_has_logical_processors(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cpu_cycles_per_second(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total_physical_memory(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_64_bit_os(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_upload_measurement(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_prefer_not_host(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CDOTAClientHardwareSpecs::CDOTAClientHardwareSpecs(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CDOTAClientHardwareSpecs)
}
CDOTAClientHardwareSpecs::CDOTAClientHardwareSpecs(const CDOTAClientHardwareSpecs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&cpu_cycles_per_second_, &from.cpu_cycles_per_second_,
    static_cast<size_t>(reinterpret_cast<char*>(&upload_measurement_) -
    reinterpret_cast<char*>(&cpu_cycles_per_second_)) + sizeof(upload_measurement_));
  // @@protoc_insertion_point(copy_constructor:CDOTAClientHardwareSpecs)
}

void CDOTAClientHardwareSpecs::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cpu_cycles_per_second_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&upload_measurement_) -
    reinterpret_cast<char*>(&cpu_cycles_per_second_)) + sizeof(upload_measurement_));
}

CDOTAClientHardwareSpecs::~CDOTAClientHardwareSpecs() {
  // @@protoc_insertion_point(destructor:CDOTAClientHardwareSpecs)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CDOTAClientHardwareSpecs::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CDOTAClientHardwareSpecs::ArenaDtor(void* object) {
  CDOTAClientHardwareSpecs* _this = reinterpret_cast< CDOTAClientHardwareSpecs* >(object);
  (void)_this;
}
void CDOTAClientHardwareSpecs::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDOTAClientHardwareSpecs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDOTAClientHardwareSpecs::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTAClientHardwareSpecs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&cpu_cycles_per_second_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&upload_measurement_) -
        reinterpret_cast<char*>(&cpu_cycles_per_second_)) + sizeof(upload_measurement_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTAClientHardwareSpecs::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 logical_processors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_logical_processors(&has_bits);
          logical_processors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional fixed64 cpu_cycles_per_second = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_cpu_cycles_per_second(&has_bits);
          cpu_cycles_per_second_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional fixed64 total_physical_memory = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_total_physical_memory(&has_bits);
          total_physical_memory_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional bool is_64_bit_os = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_is_64_bit_os(&has_bits);
          is_64_bit_os_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 upload_measurement = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_upload_measurement(&has_bits);
          upload_measurement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool prefer_not_host = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_prefer_not_host(&has_bits);
          prefer_not_host_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CDOTAClientHardwareSpecs::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTAClientHardwareSpecs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 logical_processors = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_logical_processors(), target);
  }

  // optional fixed64 cpu_cycles_per_second = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_cpu_cycles_per_second(), target);
  }

  // optional fixed64 total_physical_memory = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(3, this->_internal_total_physical_memory(), target);
  }

  // optional bool is_64_bit_os = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_64_bit_os(), target);
  }

  // optional uint64 upload_measurement = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_upload_measurement(), target);
  }

  // optional bool prefer_not_host = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_prefer_not_host(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTAClientHardwareSpecs)
  return target;
}

size_t CDOTAClientHardwareSpecs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTAClientHardwareSpecs)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional fixed64 cpu_cycles_per_second = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 total_physical_memory = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 logical_processors = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_logical_processors());
    }

    // optional bool is_64_bit_os = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool prefer_not_host = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint64 upload_measurement = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_upload_measurement());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CDOTAClientHardwareSpecs::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CDOTAClientHardwareSpecs)
  GOOGLE_DCHECK_NE(&from, this);
  const CDOTAClientHardwareSpecs* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CDOTAClientHardwareSpecs>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CDOTAClientHardwareSpecs)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CDOTAClientHardwareSpecs)
    MergeFrom(*source);
  }
}

void CDOTAClientHardwareSpecs::MergeFrom(const CDOTAClientHardwareSpecs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDOTAClientHardwareSpecs)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      cpu_cycles_per_second_ = from.cpu_cycles_per_second_;
    }
    if (cached_has_bits & 0x00000002u) {
      total_physical_memory_ = from.total_physical_memory_;
    }
    if (cached_has_bits & 0x00000004u) {
      logical_processors_ = from.logical_processors_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_64_bit_os_ = from.is_64_bit_os_;
    }
    if (cached_has_bits & 0x00000010u) {
      prefer_not_host_ = from.prefer_not_host_;
    }
    if (cached_has_bits & 0x00000020u) {
      upload_measurement_ = from.upload_measurement_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CDOTAClientHardwareSpecs::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CDOTAClientHardwareSpecs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CDOTAClientHardwareSpecs::CopyFrom(const CDOTAClientHardwareSpecs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTAClientHardwareSpecs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTAClientHardwareSpecs::IsInitialized() const {
  return true;
}

void CDOTAClientHardwareSpecs::InternalSwap(CDOTAClientHardwareSpecs* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTAClientHardwareSpecs, upload_measurement_)
      + sizeof(CDOTAClientHardwareSpecs::upload_measurement_)
      - PROTOBUF_FIELD_OFFSET(CDOTAClientHardwareSpecs, cpu_cycles_per_second_)>(
          reinterpret_cast<char*>(&cpu_cycles_per_second_),
          reinterpret_cast<char*>(&other->cpu_cycles_per_second_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTAClientHardwareSpecs::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CDOTASaveGame_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTASaveGame_Player>()._has_bits_);
  static void set_has_team(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTASaveGame_Player::CDOTASaveGame_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CDOTASaveGame.Player)
}
CDOTASaveGame_Player::CDOTASaveGame_Player(const CDOTASaveGame_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArena());
  }
  hero_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hero()) {
    hero_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hero(), 
      GetArena());
  }
  team_ = from.team_;
  // @@protoc_insertion_point(copy_constructor:CDOTASaveGame.Player)
}

void CDOTASaveGame_Player::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
hero_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
team_ = 0;
}

CDOTASaveGame_Player::~CDOTASaveGame_Player() {
  // @@protoc_insertion_point(destructor:CDOTASaveGame.Player)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CDOTASaveGame_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hero_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CDOTASaveGame_Player::ArenaDtor(void* object) {
  CDOTASaveGame_Player* _this = reinterpret_cast< CDOTASaveGame_Player* >(object);
  (void)_this;
}
void CDOTASaveGame_Player::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDOTASaveGame_Player::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDOTASaveGame_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTASaveGame.Player)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      hero_.ClearNonDefaultToEmpty();
    }
  }
  team_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTASaveGame_Player::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_GC_TEAM_IsValid(val))) {
            _internal_set_team(static_cast<::DOTA_GC_TEAM>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDOTASaveGame.Player.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string hero = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_hero();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDOTASaveGame.Player.hero");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CDOTASaveGame_Player::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTASaveGame.Player)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_team(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTASaveGame.Player.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string hero = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hero().data(), static_cast<int>(this->_internal_hero().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDOTASaveGame.Player.hero");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_hero(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTASaveGame.Player)
  return target;
}

size_t CDOTASaveGame_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTASaveGame.Player)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string hero = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hero());
    }

    // optional .DOTA_GC_TEAM team = 1 [default = DOTA_GC_TEAM_GOOD_GUYS];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_team());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CDOTASaveGame_Player::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CDOTASaveGame.Player)
  GOOGLE_DCHECK_NE(&from, this);
  const CDOTASaveGame_Player* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CDOTASaveGame_Player>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CDOTASaveGame.Player)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CDOTASaveGame.Player)
    MergeFrom(*source);
  }
}

void CDOTASaveGame_Player::MergeFrom(const CDOTASaveGame_Player& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDOTASaveGame.Player)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_hero(from._internal_hero());
    }
    if (cached_has_bits & 0x00000004u) {
      team_ = from.team_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CDOTASaveGame_Player::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CDOTASaveGame.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CDOTASaveGame_Player::CopyFrom(const CDOTASaveGame_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTASaveGame.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTASaveGame_Player::IsInitialized() const {
  return true;
}

void CDOTASaveGame_Player::InternalSwap(CDOTASaveGame_Player* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  hero_.Swap(&other->hero_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(team_, other->team_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTASaveGame_Player::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CDOTASaveGame_SaveInstance_PlayerPositions::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTASaveGame_SaveInstance_PlayerPositions>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTASaveGame_SaveInstance_PlayerPositions::CDOTASaveGame_SaveInstance_PlayerPositions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CDOTASaveGame.SaveInstance.PlayerPositions)
}
CDOTASaveGame_SaveInstance_PlayerPositions::CDOTASaveGame_SaveInstance_PlayerPositions(const CDOTASaveGame_SaveInstance_PlayerPositions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:CDOTASaveGame.SaveInstance.PlayerPositions)
}

void CDOTASaveGame_SaveInstance_PlayerPositions::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

CDOTASaveGame_SaveInstance_PlayerPositions::~CDOTASaveGame_SaveInstance_PlayerPositions() {
  // @@protoc_insertion_point(destructor:CDOTASaveGame.SaveInstance.PlayerPositions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CDOTASaveGame_SaveInstance_PlayerPositions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CDOTASaveGame_SaveInstance_PlayerPositions::ArenaDtor(void* object) {
  CDOTASaveGame_SaveInstance_PlayerPositions* _this = reinterpret_cast< CDOTASaveGame_SaveInstance_PlayerPositions* >(object);
  (void)_this;
}
void CDOTASaveGame_SaveInstance_PlayerPositions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDOTASaveGame_SaveInstance_PlayerPositions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDOTASaveGame_SaveInstance_PlayerPositions::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTASaveGame_SaveInstance_PlayerPositions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CDOTASaveGame_SaveInstance_PlayerPositions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTASaveGame.SaveInstance.PlayerPositions)
  return target;
}

size_t CDOTASaveGame_SaveInstance_PlayerPositions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CDOTASaveGame_SaveInstance_PlayerPositions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  GOOGLE_DCHECK_NE(&from, this);
  const CDOTASaveGame_SaveInstance_PlayerPositions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CDOTASaveGame_SaveInstance_PlayerPositions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CDOTASaveGame.SaveInstance.PlayerPositions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CDOTASaveGame.SaveInstance.PlayerPositions)
    MergeFrom(*source);
  }
}

void CDOTASaveGame_SaveInstance_PlayerPositions::MergeFrom(const CDOTASaveGame_SaveInstance_PlayerPositions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CDOTASaveGame_SaveInstance_PlayerPositions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CDOTASaveGame_SaveInstance_PlayerPositions::CopyFrom(const CDOTASaveGame_SaveInstance_PlayerPositions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTASaveGame.SaveInstance.PlayerPositions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTASaveGame_SaveInstance_PlayerPositions::IsInitialized() const {
  return true;
}

void CDOTASaveGame_SaveInstance_PlayerPositions::InternalSwap(CDOTASaveGame_SaveInstance_PlayerPositions* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTASaveGame_SaveInstance_PlayerPositions, y_)
      + sizeof(CDOTASaveGame_SaveInstance_PlayerPositions::y_)
      - PROTOBUF_FIELD_OFFSET(CDOTASaveGame_SaveInstance_PlayerPositions, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTASaveGame_SaveInstance_PlayerPositions::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CDOTASaveGame_SaveInstance::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTASaveGame_SaveInstance>()._has_bits_);
  static void set_has_game_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_team1_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_team2_score(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_save_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_save_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CDOTASaveGame_SaveInstance::CDOTASaveGame_SaveInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  player_positions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CDOTASaveGame.SaveInstance)
}
CDOTASaveGame_SaveInstance::CDOTASaveGame_SaveInstance(const CDOTASaveGame_SaveInstance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      player_positions_(from.player_positions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&game_time_, &from.game_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&save_time_) -
    reinterpret_cast<char*>(&game_time_)) + sizeof(save_time_));
  // @@protoc_insertion_point(copy_constructor:CDOTASaveGame.SaveInstance)
}

void CDOTASaveGame_SaveInstance::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&game_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&save_time_) -
    reinterpret_cast<char*>(&game_time_)) + sizeof(save_time_));
}

CDOTASaveGame_SaveInstance::~CDOTASaveGame_SaveInstance() {
  // @@protoc_insertion_point(destructor:CDOTASaveGame.SaveInstance)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CDOTASaveGame_SaveInstance::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CDOTASaveGame_SaveInstance::ArenaDtor(void* object) {
  CDOTASaveGame_SaveInstance* _this = reinterpret_cast< CDOTASaveGame_SaveInstance* >(object);
  (void)_this;
}
void CDOTASaveGame_SaveInstance::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDOTASaveGame_SaveInstance::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDOTASaveGame_SaveInstance::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTASaveGame.SaveInstance)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  player_positions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&game_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&save_time_) -
        reinterpret_cast<char*>(&game_time_)) + sizeof(save_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTASaveGame_SaveInstance::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 game_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_game_time(&has_bits);
          game_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 team1_score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_team1_score(&has_bits);
          team1_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 team2_score = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_team2_score(&has_bits);
          team2_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .CDOTASaveGame.SaveInstance.PlayerPositions player_positions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_positions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 save_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_save_id(&has_bits);
          save_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 save_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_save_time(&has_bits);
          save_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CDOTASaveGame_SaveInstance::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTASaveGame.SaveInstance)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 game_time = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_game_time(), target);
  }

  // optional uint32 team1_score = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_team1_score(), target);
  }

  // optional uint32 team2_score = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_team2_score(), target);
  }

  // repeated .CDOTASaveGame.SaveInstance.PlayerPositions player_positions = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_player_positions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_player_positions(i), target, stream);
  }

  // optional uint32 save_id = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_save_id(), target);
  }

  // optional uint32 save_time = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_save_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTASaveGame.SaveInstance)
  return target;
}

size_t CDOTASaveGame_SaveInstance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTASaveGame.SaveInstance)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CDOTASaveGame.SaveInstance.PlayerPositions player_positions = 5;
  total_size += 1UL * this->_internal_player_positions_size();
  for (const auto& msg : this->player_positions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 game_time = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_game_time());
    }

    // optional uint32 team1_score = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_team1_score());
    }

    // optional uint32 team2_score = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_team2_score());
    }

    // optional uint32 save_id = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_save_id());
    }

    // optional uint32 save_time = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_save_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CDOTASaveGame_SaveInstance::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CDOTASaveGame.SaveInstance)
  GOOGLE_DCHECK_NE(&from, this);
  const CDOTASaveGame_SaveInstance* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CDOTASaveGame_SaveInstance>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CDOTASaveGame.SaveInstance)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CDOTASaveGame.SaveInstance)
    MergeFrom(*source);
  }
}

void CDOTASaveGame_SaveInstance::MergeFrom(const CDOTASaveGame_SaveInstance& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDOTASaveGame.SaveInstance)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  player_positions_.MergeFrom(from.player_positions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      game_time_ = from.game_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      team1_score_ = from.team1_score_;
    }
    if (cached_has_bits & 0x00000004u) {
      team2_score_ = from.team2_score_;
    }
    if (cached_has_bits & 0x00000008u) {
      save_id_ = from.save_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      save_time_ = from.save_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CDOTASaveGame_SaveInstance::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CDOTASaveGame.SaveInstance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CDOTASaveGame_SaveInstance::CopyFrom(const CDOTASaveGame_SaveInstance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTASaveGame.SaveInstance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTASaveGame_SaveInstance::IsInitialized() const {
  return true;
}

void CDOTASaveGame_SaveInstance::InternalSwap(CDOTASaveGame_SaveInstance* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  player_positions_.InternalSwap(&other->player_positions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTASaveGame_SaveInstance, save_time_)
      + sizeof(CDOTASaveGame_SaveInstance::save_time_)
      - PROTOBUF_FIELD_OFFSET(CDOTASaveGame_SaveInstance, game_time_)>(
          reinterpret_cast<char*>(&game_time_),
          reinterpret_cast<char*>(&other->game_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTASaveGame_SaveInstance::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CDOTASaveGame::_Internal {
 public:
  using HasBits = decltype(std::declval<CDOTASaveGame>()._has_bits_);
  static void set_has_match_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_save_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDOTASaveGame::CDOTASaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  players_(arena),
  save_instances_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CDOTASaveGame)
}
CDOTASaveGame::CDOTASaveGame(const CDOTASaveGame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      players_(from.players_),
      save_instances_(from.save_instances_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&match_id_, &from.match_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&save_time_) -
    reinterpret_cast<char*>(&match_id_)) + sizeof(save_time_));
  // @@protoc_insertion_point(copy_constructor:CDOTASaveGame)
}

void CDOTASaveGame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&match_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&save_time_) -
    reinterpret_cast<char*>(&match_id_)) + sizeof(save_time_));
}

CDOTASaveGame::~CDOTASaveGame() {
  // @@protoc_insertion_point(destructor:CDOTASaveGame)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CDOTASaveGame::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CDOTASaveGame::ArenaDtor(void* object) {
  CDOTASaveGame* _this = reinterpret_cast< CDOTASaveGame* >(object);
  (void)_this;
}
void CDOTASaveGame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDOTASaveGame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDOTASaveGame::Clear() {
// @@protoc_insertion_point(message_clear_start:CDOTASaveGame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  players_.Clear();
  save_instances_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&match_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&save_time_) -
        reinterpret_cast<char*>(&match_id_)) + sizeof(save_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDOTASaveGame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 save_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_save_time(&has_bits);
          save_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .CDOTASaveGame.Player players = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .CDOTASaveGame.SaveInstance save_instances = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_save_instances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 match_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_match_id(&has_bits);
          match_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CDOTASaveGame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDOTASaveGame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 save_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_save_time(), target);
  }

  // repeated .CDOTASaveGame.Player players = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_players_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_players(i), target, stream);
  }

  // repeated .CDOTASaveGame.SaveInstance save_instances = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_save_instances_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_save_instances(i), target, stream);
  }

  // optional uint64 match_id = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_match_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDOTASaveGame)
  return target;
}

size_t CDOTASaveGame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDOTASaveGame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CDOTASaveGame.Player players = 3;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CDOTASaveGame.SaveInstance save_instances = 4;
  total_size += 1UL * this->_internal_save_instances_size();
  for (const auto& msg : this->save_instances_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 match_id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_match_id());
    }

    // optional uint32 save_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_save_time());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CDOTASaveGame::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CDOTASaveGame)
  GOOGLE_DCHECK_NE(&from, this);
  const CDOTASaveGame* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CDOTASaveGame>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CDOTASaveGame)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CDOTASaveGame)
    MergeFrom(*source);
  }
}

void CDOTASaveGame::MergeFrom(const CDOTASaveGame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDOTASaveGame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  players_.MergeFrom(from.players_);
  save_instances_.MergeFrom(from.save_instances_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      match_id_ = from.match_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      save_time_ = from.save_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CDOTASaveGame::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CDOTASaveGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CDOTASaveGame::CopyFrom(const CDOTASaveGame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDOTASaveGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDOTASaveGame::IsInitialized() const {
  return true;
}

void CDOTASaveGame::InternalSwap(CDOTASaveGame* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  players_.InternalSwap(&other->players_);
  save_instances_.InternalSwap(&other->save_instances_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDOTASaveGame, save_time_)
      + sizeof(CDOTASaveGame::save_time_)
      - PROTOBUF_FIELD_OFFSET(CDOTASaveGame, match_id_)>(
          reinterpret_cast<char*>(&match_id_),
          reinterpret_cast<char*>(&other->match_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDOTASaveGame::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgDOTACombatLogEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgDOTACombatLogEntry>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[2] |= 512u;
  }
  static void set_has_target_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_target_source_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attacker_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_damage_source_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_inflictor_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_attacker_illusion(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_attacker_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_target_illusion(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_target_hero(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_visible_radiant(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_visible_dire(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_health(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_stun_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_slow_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_ability_toggle_on(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_ability_toggle_off(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_ability_level(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_location_x(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_location_y(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_gold_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_timestamp_raw(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_modifier_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_xp_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_last_hits(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_attacker_team(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_target_team(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_obs_wards_placed(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_assist_player0(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_assist_player1(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_assist_player2(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_assist_player3(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_stack_count(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_hidden_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_is_target_building(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_neutral_camp_type(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_rune_type(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_is_heal_save(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_is_ultimate_ability(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_attacker_hero_level(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_target_hero_level(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_xpm(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_gpm(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_event_location(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_target_is_self(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_damage_type(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_invisibility_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_damage_category(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_networth(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_building_type(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_modifier_elapsed_duration(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_silence_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_heal_from_lifesteal(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_modifier_purged(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_spell_evaded(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_motion_controller_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_long_range_kill(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static void set_has_modifier_purge_ability(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static void set_has_modifier_purge_npc(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static void set_has_root_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 536870912u;
  }
  static void set_has_total_unit_death_count(HasBits* has_bits) {
    (*has_bits)[1] |= 268435456u;
  }
  static void set_has_aura_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 1073741824u;
  }
  static void set_has_armor_debuff_modifier(HasBits* has_bits) {
    (*has_bits)[1] |= 2147483648u;
  }
  static void set_has_no_physical_damage_modifier(HasBits* has_bits) {
    (*has_bits)[2] |= 1u;
  }
  static void set_has_modifier_ability(HasBits* has_bits) {
    (*has_bits)[2] |= 2u;
  }
  static void set_has_modifier_hidden(HasBits* has_bits) {
    (*has_bits)[2] |= 8u;
  }
  static void set_has_inflictor_is_stolen_ability(HasBits* has_bits) {
    (*has_bits)[2] |= 16u;
  }
  static void set_has_kill_eater_event(HasBits* has_bits) {
    (*has_bits)[2] |= 4u;
  }
  static void set_has_unit_status_label(HasBits* has_bits) {
    (*has_bits)[2] |= 128u;
  }
  static void set_has_spell_generated_attack(HasBits* has_bits) {
    (*has_bits)[2] |= 32u;
  }
  static void set_has_at_night_time(HasBits* has_bits) {
    (*has_bits)[2] |= 64u;
  }
  static void set_has_attacker_has_scepter(HasBits* has_bits) {
    (*has_bits)[2] |= 256u;
  }
};

CMsgDOTACombatLogEntry::CMsgDOTACombatLogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  assist_players_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgDOTACombatLogEntry)
}
CMsgDOTACombatLogEntry::CMsgDOTACombatLogEntry(const CMsgDOTACombatLogEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      assist_players_(from.assist_players_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&target_name_, &from.target_name_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&target_name_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:CMsgDOTACombatLogEntry)
}

void CMsgDOTACombatLogEntry::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&target_name_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&attacker_has_scepter_) -
    reinterpret_cast<char*>(&target_name_)) + sizeof(attacker_has_scepter_));
type_ = -1;
}

CMsgDOTACombatLogEntry::~CMsgDOTACombatLogEntry() {
  // @@protoc_insertion_point(destructor:CMsgDOTACombatLogEntry)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgDOTACombatLogEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CMsgDOTACombatLogEntry::ArenaDtor(void* object) {
  CMsgDOTACombatLogEntry* _this = reinterpret_cast< CMsgDOTACombatLogEntry* >(object);
  (void)_this;
}
void CMsgDOTACombatLogEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgDOTACombatLogEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgDOTACombatLogEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgDOTACombatLogEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  assist_players_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&target_name_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_target_illusion_) -
        reinterpret_cast<char*>(&target_name_)) + sizeof(is_target_illusion_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&is_target_hero_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_ability_toggle_off_) -
        reinterpret_cast<char*>(&is_target_hero_)) + sizeof(is_ability_toggle_off_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&stun_duration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&modifier_duration_) -
        reinterpret_cast<char*>(&stun_duration_)) + sizeof(modifier_duration_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&xp_reason_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&assist_player2_) -
        reinterpret_cast<char*>(&xp_reason_)) + sizeof(assist_player2_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&assist_player3_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_ultimate_ability_) -
        reinterpret_cast<char*>(&assist_player3_)) + sizeof(is_ultimate_ability_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&attacker_hero_level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&networth_) -
        reinterpret_cast<char*>(&attacker_hero_level_)) + sizeof(networth_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&target_is_self_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&spell_evaded_) -
        reinterpret_cast<char*>(&target_is_self_)) + sizeof(spell_evaded_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&motion_controller_modifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&armor_debuff_modifier_) -
        reinterpret_cast<char*>(&motion_controller_modifier_)) + sizeof(armor_debuff_modifier_));
  }
  cached_has_bits = _has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&no_physical_damage_modifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unit_status_label_) -
        reinterpret_cast<char*>(&no_physical_damage_modifier_)) + sizeof(unit_status_label_));
  }
  if (cached_has_bits & 0x00000300u) {
    attacker_has_scepter_ = false;
    type_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgDOTACombatLogEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .DOTA_COMBATLOG_TYPES type = 1 [default = DOTA_COMBATLOG_INVALID];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::DOTA_COMBATLOG_TYPES_IsValid(val))) {
            _internal_set_type(static_cast<::DOTA_COMBATLOG_TYPES>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 target_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_target_name(&_has_bits_);
          target_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 target_source_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_target_source_name(&_has_bits_);
          target_source_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 attacker_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_attacker_name(&_has_bits_);
          attacker_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 damage_source_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_damage_source_name(&_has_bits_);
          damage_source_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 inflictor_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_inflictor_name(&_has_bits_);
          inflictor_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_attacker_illusion = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_is_attacker_illusion(&_has_bits_);
          is_attacker_illusion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_attacker_hero = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_is_attacker_hero(&_has_bits_);
          is_attacker_hero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_target_illusion = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_is_target_illusion(&_has_bits_);
          is_target_illusion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_target_hero = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_is_target_hero(&_has_bits_);
          is_target_hero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_visible_radiant = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_is_visible_radiant(&_has_bits_);
          is_visible_radiant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_visible_dire = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_is_visible_dire(&_has_bits_);
          is_visible_dire_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 value = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_value(&_has_bits_);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 health = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_health(&_has_bits_);
          health_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float timestamp = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_timestamp(&_has_bits_);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float stun_duration = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 133)) {
          _Internal::set_has_stun_duration(&_has_bits_);
          stun_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float slow_duration = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_slow_duration(&_has_bits_);
          slow_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool is_ability_toggle_on = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_is_ability_toggle_on(&_has_bits_);
          is_ability_toggle_on_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_ability_toggle_off = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_is_ability_toggle_off(&_has_bits_);
          is_ability_toggle_off_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ability_level = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_ability_level(&_has_bits_);
          ability_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float location_x = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 173)) {
          _Internal::set_has_location_x(&_has_bits_);
          location_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float location_y = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 181)) {
          _Internal::set_has_location_y(&_has_bits_);
          location_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 gold_reason = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_gold_reason(&_has_bits_);
          gold_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float timestamp_raw = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 197)) {
          _Internal::set_has_timestamp_raw(&_has_bits_);
          timestamp_raw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float modifier_duration = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 205)) {
          _Internal::set_has_modifier_duration(&_has_bits_);
          modifier_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 xp_reason = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_xp_reason(&_has_bits_);
          xp_reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 last_hits = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_last_hits(&_has_bits_);
          last_hits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 attacker_team = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_attacker_team(&_has_bits_);
          attacker_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 target_team = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_target_team(&_has_bits_);
          target_team_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 obs_wards_placed = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_obs_wards_placed(&_has_bits_);
          obs_wards_placed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 assist_player0 = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_assist_player0(&_has_bits_);
          assist_player0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 assist_player1 = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_assist_player1(&_has_bits_);
          assist_player1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 assist_player2 = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_assist_player2(&_has_bits_);
          assist_player2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 assist_player3 = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_assist_player3(&_has_bits_);
          assist_player3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 stack_count = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_stack_count(&_has_bits_);
          stack_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool hidden_modifier = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_hidden_modifier(&_has_bits_);
          hidden_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_target_building = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_is_target_building(&_has_bits_);
          is_target_building_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 neutral_camp_type = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_neutral_camp_type(&_has_bits_);
          neutral_camp_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 rune_type = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_rune_type(&_has_bits_);
          rune_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 assist_players = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_assist_players(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<320>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_assist_players(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_heal_save = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_is_heal_save(&_has_bits_);
          is_heal_save_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_ultimate_ability = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_is_ultimate_ability(&_has_bits_);
          is_ultimate_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 attacker_hero_level = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_attacker_hero_level(&_has_bits_);
          attacker_hero_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 target_hero_level = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_target_hero_level(&_has_bits_);
          target_hero_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 xpm = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_xpm(&_has_bits_);
          xpm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 gpm = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_gpm(&_has_bits_);
          gpm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 event_location = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_event_location(&_has_bits_);
          event_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool target_is_self = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_target_is_self(&_has_bits_);
          target_is_self_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 damage_type = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_damage_type(&_has_bits_);
          damage_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool invisibility_modifier = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_invisibility_modifier(&_has_bits_);
          invisibility_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 damage_category = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_damage_category(&_has_bits_);
          damage_category_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 networth = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_networth(&_has_bits_);
          networth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 building_type = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _Internal::set_has_building_type(&_has_bits_);
          building_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float modifier_elapsed_duration = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 181)) {
          _Internal::set_has_modifier_elapsed_duration(&_has_bits_);
          modifier_elapsed_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool silence_modifier = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_silence_modifier(&_has_bits_);
          silence_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool heal_from_lifesteal = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_heal_from_lifesteal(&_has_bits_);
          heal_from_lifesteal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool modifier_purged = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          _Internal::set_has_modifier_purged(&_has_bits_);
          modifier_purged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool spell_evaded = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_spell_evaded(&_has_bits_);
          spell_evaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool motion_controller_modifier = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_motion_controller_modifier(&_has_bits_);
          motion_controller_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool long_range_kill = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_long_range_kill(&_has_bits_);
          long_range_kill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 modifier_purge_ability = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_modifier_purge_ability(&_has_bits_);
          modifier_purge_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 modifier_purge_npc = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_modifier_purge_npc(&_has_bits_);
          modifier_purge_npc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool root_modifier = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_root_modifier(&_has_bits_);
          root_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 total_unit_death_count = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_total_unit_death_count(&_has_bits_);
          total_unit_death_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool aura_modifier = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_aura_modifier(&_has_bits_);
          aura_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool armor_debuff_modifier = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_armor_debuff_modifier(&_has_bits_);
          armor_debuff_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool no_physical_damage_modifier = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_no_physical_damage_modifier(&_has_bits_);
          no_physical_damage_modifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 modifier_ability = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_modifier_ability(&_has_bits_);
          modifier_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool modifier_hidden = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_modifier_hidden(&_has_bits_);
          modifier_hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool inflictor_is_stolen_ability = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_inflictor_is_stolen_ability(&_has_bits_);
          inflictor_is_stolen_ability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 kill_eater_event = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_kill_eater_event(&_has_bits_);
          kill_eater_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 unit_status_label = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_unit_status_label(&_has_bits_);
          unit_status_label_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool spell_generated_attack = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_spell_generated_attack(&_has_bits_);
          spell_generated_attack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool at_night_time = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_at_night_time(&_has_bits_);
          at_night_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool attacker_has_scepter = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_attacker_has_scepter(&_has_bits_);
          attacker_has_scepter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgDOTACombatLogEntry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgDOTACombatLogEntry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[2];
  // optional .DOTA_COMBATLOG_TYPES type = 1 [default = DOTA_COMBATLOG_INVALID];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 target_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_target_name(), target);
  }

  // optional uint32 target_source_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_target_source_name(), target);
  }

  // optional uint32 attacker_name = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_attacker_name(), target);
  }

  // optional uint32 damage_source_name = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_damage_source_name(), target);
  }

  // optional uint32 inflictor_name = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_inflictor_name(), target);
  }

  // optional bool is_attacker_illusion = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_attacker_illusion(), target);
  }

  // optional bool is_attacker_hero = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is_attacker_hero(), target);
  }

  // optional bool is_target_illusion = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_target_illusion(), target);
  }

  // optional bool is_target_hero = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_target_hero(), target);
  }

  // optional bool is_visible_radiant = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_is_visible_radiant(), target);
  }

  // optional bool is_visible_dire = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_is_visible_dire(), target);
  }

  // optional uint32 value = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_value(), target);
  }

  // optional int32 health = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(14, this->_internal_health(), target);
  }

  // optional float timestamp = 15;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_timestamp(), target);
  }

  // optional float stun_duration = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(16, this->_internal_stun_duration(), target);
  }

  // optional float slow_duration = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_slow_duration(), target);
  }

  // optional bool is_ability_toggle_on = 18;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_is_ability_toggle_on(), target);
  }

  // optional bool is_ability_toggle_off = 19;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_is_ability_toggle_off(), target);
  }

  // optional uint32 ability_level = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(20, this->_internal_ability_level(), target);
  }

  // optional float location_x = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(21, this->_internal_location_x(), target);
  }

  // optional float location_y = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(22, this->_internal_location_y(), target);
  }

  // optional uint32 gold_reason = 23;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(23, this->_internal_gold_reason(), target);
  }

  // optional float timestamp_raw = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(24, this->_internal_timestamp_raw(), target);
  }

  // optional float modifier_duration = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(25, this->_internal_modifier_duration(), target);
  }

  // optional uint32 xp_reason = 26;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(26, this->_internal_xp_reason(), target);
  }

  // optional uint32 last_hits = 27;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(27, this->_internal_last_hits(), target);
  }

  // optional uint32 attacker_team = 28;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(28, this->_internal_attacker_team(), target);
  }

  // optional uint32 target_team = 29;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(29, this->_internal_target_team(), target);
  }

  // optional uint32 obs_wards_placed = 30;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(30, this->_internal_obs_wards_placed(), target);
  }

  // optional uint32 assist_player0 = 31;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(31, this->_internal_assist_player0(), target);
  }

  // optional uint32 assist_player1 = 32;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(32, this->_internal_assist_player1(), target);
  }

  // optional uint32 assist_player2 = 33;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(33, this->_internal_assist_player2(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint32 assist_player3 = 34;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(34, this->_internal_assist_player3(), target);
  }

  // optional uint32 stack_count = 35;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(35, this->_internal_stack_count(), target);
  }

  // optional bool hidden_modifier = 36;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(36, this->_internal_hidden_modifier(), target);
  }

  // optional bool is_target_building = 37;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(37, this->_internal_is_target_building(), target);
  }

  // optional uint32 neutral_camp_type = 38;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(38, this->_internal_neutral_camp_type(), target);
  }

  // optional uint32 rune_type = 39;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(39, this->_internal_rune_type(), target);
  }

  // repeated uint32 assist_players = 40;
  for (int i = 0, n = this->_internal_assist_players_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(40, this->_internal_assist_players(i), target);
  }

  // optional bool is_heal_save = 41;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(41, this->_internal_is_heal_save(), target);
  }

  // optional bool is_ultimate_ability = 42;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(42, this->_internal_is_ultimate_ability(), target);
  }

  // optional uint32 attacker_hero_level = 43;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(43, this->_internal_attacker_hero_level(), target);
  }

  // optional uint32 target_hero_level = 44;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(44, this->_internal_target_hero_level(), target);
  }

  // optional uint32 xpm = 45;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(45, this->_internal_xpm(), target);
  }

  // optional uint32 gpm = 46;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(46, this->_internal_gpm(), target);
  }

  // optional uint32 event_location = 47;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(47, this->_internal_event_location(), target);
  }

  // optional bool target_is_self = 48;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(48, this->_internal_target_is_self(), target);
  }

  // optional uint32 damage_type = 49;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(49, this->_internal_damage_type(), target);
  }

  // optional bool invisibility_modifier = 50;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(50, this->_internal_invisibility_modifier(), target);
  }

  // optional uint32 damage_category = 51;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(51, this->_internal_damage_category(), target);
  }

  // optional uint32 networth = 52;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(52, this->_internal_networth(), target);
  }

  // optional uint32 building_type = 53;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(53, this->_internal_building_type(), target);
  }

  // optional float modifier_elapsed_duration = 54;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(54, this->_internal_modifier_elapsed_duration(), target);
  }

  // optional bool silence_modifier = 55;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(55, this->_internal_silence_modifier(), target);
  }

  // optional bool heal_from_lifesteal = 56;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(56, this->_internal_heal_from_lifesteal(), target);
  }

  // optional bool modifier_purged = 57;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(57, this->_internal_modifier_purged(), target);
  }

  // optional bool spell_evaded = 58;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(58, this->_internal_spell_evaded(), target);
  }

  // optional bool motion_controller_modifier = 59;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(59, this->_internal_motion_controller_modifier(), target);
  }

  // optional bool long_range_kill = 60;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(60, this->_internal_long_range_kill(), target);
  }

  // optional uint32 modifier_purge_ability = 61;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(61, this->_internal_modifier_purge_ability(), target);
  }

  // optional uint32 modifier_purge_npc = 62;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(62, this->_internal_modifier_purge_npc(), target);
  }

  // optional bool root_modifier = 63;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(63, this->_internal_root_modifier(), target);
  }

  // optional uint32 total_unit_death_count = 64;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(64, this->_internal_total_unit_death_count(), target);
  }

  // optional bool aura_modifier = 65;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(65, this->_internal_aura_modifier(), target);
  }

  // optional bool armor_debuff_modifier = 66;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(66, this->_internal_armor_debuff_modifier(), target);
  }

  cached_has_bits = _has_bits_[2];
  // optional bool no_physical_damage_modifier = 67;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(67, this->_internal_no_physical_damage_modifier(), target);
  }

  // optional uint32 modifier_ability = 68;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(68, this->_internal_modifier_ability(), target);
  }

  // optional bool modifier_hidden = 69;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(69, this->_internal_modifier_hidden(), target);
  }

  // optional bool inflictor_is_stolen_ability = 70;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(70, this->_internal_inflictor_is_stolen_ability(), target);
  }

  // optional uint32 kill_eater_event = 71;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(71, this->_internal_kill_eater_event(), target);
  }

  // optional uint32 unit_status_label = 72;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(72, this->_internal_unit_status_label(), target);
  }

  // optional bool spell_generated_attack = 73;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(73, this->_internal_spell_generated_attack(), target);
  }

  // optional bool at_night_time = 74;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(74, this->_internal_at_night_time(), target);
  }

  // optional bool attacker_has_scepter = 75;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(75, this->_internal_attacker_has_scepter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgDOTACombatLogEntry)
  return target;
}

size_t CMsgDOTACombatLogEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgDOTACombatLogEntry)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 assist_players = 40;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->assist_players_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_assist_players_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 target_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_target_name());
    }

    // optional uint32 target_source_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_target_source_name());
    }

    // optional uint32 attacker_name = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_attacker_name());
    }

    // optional uint32 damage_source_name = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_damage_source_name());
    }

    // optional uint32 inflictor_name = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_inflictor_name());
    }

    // optional bool is_attacker_illusion = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_attacker_hero = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_target_illusion = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool is_target_hero = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional uint32 value = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_value());
    }

    // optional int32 health = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_health());
    }

    // optional float timestamp = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional bool is_visible_radiant = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool is_visible_dire = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool is_ability_toggle_on = 18;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool is_ability_toggle_off = 19;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float stun_duration = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float slow_duration = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional uint32 ability_level = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ability_level());
    }

    // optional float location_x = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional float location_y = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

    // optional uint32 gold_reason = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_gold_reason());
    }

    // optional float timestamp_raw = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

    // optional float modifier_duration = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 xp_reason = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_xp_reason());
    }

    // optional uint32 last_hits = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_last_hits());
    }

    // optional uint32 attacker_team = 28;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_attacker_team());
    }

    // optional uint32 target_team = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_target_team());
    }

    // optional uint32 obs_wards_placed = 30;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_obs_wards_placed());
    }

    // optional uint32 assist_player0 = 31;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_assist_player0());
    }

    // optional uint32 assist_player1 = 32;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_assist_player1());
    }

    // optional uint32 assist_player2 = 33;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_assist_player2());
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 assist_player3 = 34;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_assist_player3());
    }

    // optional uint32 stack_count = 35;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_stack_count());
    }

    // optional uint32 neutral_camp_type = 38;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_neutral_camp_type());
    }

    // optional uint32 rune_type = 39;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_rune_type());
    }

    // optional bool hidden_modifier = 36;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool is_target_building = 37;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool is_heal_save = 41;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional bool is_ultimate_ability = 42;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 attacker_hero_level = 43;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_attacker_hero_level());
    }

    // optional uint32 target_hero_level = 44;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_target_hero_level());
    }

    // optional uint32 xpm = 45;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_xpm());
    }

    // optional uint32 gpm = 46;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_gpm());
    }

    // optional uint32 event_location = 47;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_event_location());
    }

    // optional uint32 damage_type = 49;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_damage_type());
    }

    // optional uint32 damage_category = 51;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_damage_category());
    }

    // optional uint32 networth = 52;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_networth());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool target_is_self = 48;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool invisibility_modifier = 50;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool silence_modifier = 55;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool heal_from_lifesteal = 56;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional uint32 building_type = 53;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_building_type());
    }

    // optional float modifier_elapsed_duration = 54;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 4;
    }

    // optional bool modifier_purged = 57;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool spell_evaded = 58;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool motion_controller_modifier = 59;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool long_range_kill = 60;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional uint32 modifier_purge_ability = 61;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_modifier_purge_ability());
    }

    // optional uint32 modifier_purge_npc = 62;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_modifier_purge_npc());
    }

    // optional uint32 total_unit_death_count = 64;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_total_unit_death_count());
    }

    // optional bool root_modifier = 63;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional bool aura_modifier = 65;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 1;
    }

    // optional bool armor_debuff_modifier = 66;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 1;
    }

  }
  cached_has_bits = _has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool no_physical_damage_modifier = 67;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional uint32 modifier_ability = 68;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_modifier_ability());
    }

    // optional uint32 kill_eater_event = 71;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_kill_eater_event());
    }

    // optional bool modifier_hidden = 69;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional bool inflictor_is_stolen_ability = 70;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool spell_generated_attack = 73;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional bool at_night_time = 74;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional uint32 unit_status_label = 72;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_unit_status_label());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool attacker_has_scepter = 75;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional .DOTA_COMBATLOG_TYPES type = 1 [default = DOTA_COMBATLOG_INVALID];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgDOTACombatLogEntry::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgDOTACombatLogEntry)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgDOTACombatLogEntry* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgDOTACombatLogEntry>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgDOTACombatLogEntry)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgDOTACombatLogEntry)
    MergeFrom(*source);
  }
}

void CMsgDOTACombatLogEntry::MergeFrom(const CMsgDOTACombatLogEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgDOTACombatLogEntry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  assist_players_.MergeFrom(from.assist_players_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      target_name_ = from.target_name_;
    }
    if (cached_has_bits & 0x00000002u) {
      target_source_name_ = from.target_source_name_;
    }
    if (cached_has_bits & 0x00000004u) {
      attacker_name_ = from.attacker_name_;
    }
    if (cached_has_bits & 0x00000008u) {
      damage_source_name_ = from.damage_source_name_;
    }
    if (cached_has_bits & 0x00000010u) {
      inflictor_name_ = from.inflictor_name_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_attacker_illusion_ = from.is_attacker_illusion_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_attacker_hero_ = from.is_attacker_hero_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_target_illusion_ = from.is_target_illusion_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      is_target_hero_ = from.is_target_hero_;
    }
    if (cached_has_bits & 0x00000200u) {
      value_ = from.value_;
    }
    if (cached_has_bits & 0x00000400u) {
      health_ = from.health_;
    }
    if (cached_has_bits & 0x00000800u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00001000u) {
      is_visible_radiant_ = from.is_visible_radiant_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_visible_dire_ = from.is_visible_dire_;
    }
    if (cached_has_bits & 0x00004000u) {
      is_ability_toggle_on_ = from.is_ability_toggle_on_;
    }
    if (cached_has_bits & 0x00008000u) {
      is_ability_toggle_off_ = from.is_ability_toggle_off_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      stun_duration_ = from.stun_duration_;
    }
    if (cached_has_bits & 0x00020000u) {
      slow_duration_ = from.slow_duration_;
    }
    if (cached_has_bits & 0x00040000u) {
      ability_level_ = from.ability_level_;
    }
    if (cached_has_bits & 0x00080000u) {
      location_x_ = from.location_x_;
    }
    if (cached_has_bits & 0x00100000u) {
      location_y_ = from.location_y_;
    }
    if (cached_has_bits & 0x00200000u) {
      gold_reason_ = from.gold_reason_;
    }
    if (cached_has_bits & 0x00400000u) {
      timestamp_raw_ = from.timestamp_raw_;
    }
    if (cached_has_bits & 0x00800000u) {
      modifier_duration_ = from.modifier_duration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      xp_reason_ = from.xp_reason_;
    }
    if (cached_has_bits & 0x02000000u) {
      last_hits_ = from.last_hits_;
    }
    if (cached_has_bits & 0x04000000u) {
      attacker_team_ = from.attacker_team_;
    }
    if (cached_has_bits & 0x08000000u) {
      target_team_ = from.target_team_;
    }
    if (cached_has_bits & 0x10000000u) {
      obs_wards_placed_ = from.obs_wards_placed_;
    }
    if (cached_has_bits & 0x20000000u) {
      assist_player0_ = from.assist_player0_;
    }
    if (cached_has_bits & 0x40000000u) {
      assist_player1_ = from.assist_player1_;
    }
    if (cached_has_bits & 0x80000000u) {
      assist_player2_ = from.assist_player2_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      assist_player3_ = from.assist_player3_;
    }
    if (cached_has_bits & 0x00000002u) {
      stack_count_ = from.stack_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      neutral_camp_type_ = from.neutral_camp_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      rune_type_ = from.rune_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      hidden_modifier_ = from.hidden_modifier_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_target_building_ = from.is_target_building_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_heal_save_ = from.is_heal_save_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_ultimate_ability_ = from.is_ultimate_ability_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      attacker_hero_level_ = from.attacker_hero_level_;
    }
    if (cached_has_bits & 0x00000200u) {
      target_hero_level_ = from.target_hero_level_;
    }
    if (cached_has_bits & 0x00000400u) {
      xpm_ = from.xpm_;
    }
    if (cached_has_bits & 0x00000800u) {
      gpm_ = from.gpm_;
    }
    if (cached_has_bits & 0x00001000u) {
      event_location_ = from.event_location_;
    }
    if (cached_has_bits & 0x00002000u) {
      damage_type_ = from.damage_type_;
    }
    if (cached_has_bits & 0x00004000u) {
      damage_category_ = from.damage_category_;
    }
    if (cached_has_bits & 0x00008000u) {
      networth_ = from.networth_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      target_is_self_ = from.target_is_self_;
    }
    if (cached_has_bits & 0x00020000u) {
      invisibility_modifier_ = from.invisibility_modifier_;
    }
    if (cached_has_bits & 0x00040000u) {
      silence_modifier_ = from.silence_modifier_;
    }
    if (cached_has_bits & 0x00080000u) {
      heal_from_lifesteal_ = from.heal_from_lifesteal_;
    }
    if (cached_has_bits & 0x00100000u) {
      building_type_ = from.building_type_;
    }
    if (cached_has_bits & 0x00200000u) {
      modifier_elapsed_duration_ = from.modifier_elapsed_duration_;
    }
    if (cached_has_bits & 0x00400000u) {
      modifier_purged_ = from.modifier_purged_;
    }
    if (cached_has_bits & 0x00800000u) {
      spell_evaded_ = from.spell_evaded_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      motion_controller_modifier_ = from.motion_controller_modifier_;
    }
    if (cached_has_bits & 0x02000000u) {
      long_range_kill_ = from.long_range_kill_;
    }
    if (cached_has_bits & 0x04000000u) {
      modifier_purge_ability_ = from.modifier_purge_ability_;
    }
    if (cached_has_bits & 0x08000000u) {
      modifier_purge_npc_ = from.modifier_purge_npc_;
    }
    if (cached_has_bits & 0x10000000u) {
      total_unit_death_count_ = from.total_unit_death_count_;
    }
    if (cached_has_bits & 0x20000000u) {
      root_modifier_ = from.root_modifier_;
    }
    if (cached_has_bits & 0x40000000u) {
      aura_modifier_ = from.aura_modifier_;
    }
    if (cached_has_bits & 0x80000000u) {
      armor_debuff_modifier_ = from.armor_debuff_modifier_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[2];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      no_physical_damage_modifier_ = from.no_physical_damage_modifier_;
    }
    if (cached_has_bits & 0x00000002u) {
      modifier_ability_ = from.modifier_ability_;
    }
    if (cached_has_bits & 0x00000004u) {
      kill_eater_event_ = from.kill_eater_event_;
    }
    if (cached_has_bits & 0x00000008u) {
      modifier_hidden_ = from.modifier_hidden_;
    }
    if (cached_has_bits & 0x00000010u) {
      inflictor_is_stolen_ability_ = from.inflictor_is_stolen_ability_;
    }
    if (cached_has_bits & 0x00000020u) {
      spell_generated_attack_ = from.spell_generated_attack_;
    }
    if (cached_has_bits & 0x00000040u) {
      at_night_time_ = from.at_night_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      unit_status_label_ = from.unit_status_label_;
    }
    _has_bits_[2] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      attacker_has_scepter_ = from.attacker_has_scepter_;
    }
    if (cached_has_bits & 0x00000200u) {
      type_ = from.type_;
    }
    _has_bits_[2] |= cached_has_bits;
  }
}

void CMsgDOTACombatLogEntry::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgDOTACombatLogEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgDOTACombatLogEntry::CopyFrom(const CMsgDOTACombatLogEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgDOTACombatLogEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgDOTACombatLogEntry::IsInitialized() const {
  return true;
}

void CMsgDOTACombatLogEntry::InternalSwap(CMsgDOTACombatLogEntry* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  swap(_has_bits_[2], other->_has_bits_[2]);
  assist_players_.InternalSwap(&other->assist_players_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgDOTACombatLogEntry, attacker_has_scepter_)
      + sizeof(CMsgDOTACombatLogEntry::attacker_has_scepter_)
      - PROTOBUF_FIELD_OFFSET(CMsgDOTACombatLogEntry, target_name_)>(
          reinterpret_cast<char*>(&target_name_),
          reinterpret_cast<char*>(&other->target_name_));
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgDOTACombatLogEntry::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgPendingEventAward::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgPendingEventAward>()._has_bits_);
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_to_grant(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_score_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_audit_action(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_audit_data(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgPendingEventAward::CMsgPendingEventAward(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgPendingEventAward)
}
CMsgPendingEventAward::CMsgPendingEventAward(const CMsgPendingEventAward& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&event_id_, &from.event_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&audit_data_) -
    reinterpret_cast<char*>(&event_id_)) + sizeof(audit_data_));
  // @@protoc_insertion_point(copy_constructor:CMsgPendingEventAward)
}

void CMsgPendingEventAward::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&event_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&audit_data_) -
    reinterpret_cast<char*>(&event_id_)) + sizeof(audit_data_));
}

CMsgPendingEventAward::~CMsgPendingEventAward() {
  // @@protoc_insertion_point(destructor:CMsgPendingEventAward)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgPendingEventAward::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CMsgPendingEventAward::ArenaDtor(void* object) {
  CMsgPendingEventAward* _this = reinterpret_cast< CMsgPendingEventAward* >(object);
  (void)_this;
}
void CMsgPendingEventAward::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgPendingEventAward::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgPendingEventAward::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgPendingEventAward)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&event_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&audit_data_) -
        reinterpret_cast<char*>(&event_id_)) + sizeof(audit_data_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgPendingEventAward::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEvent_IsValid(val))) {
            _internal_set_event_id(static_cast<::EEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 action_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_action_id(&has_bits);
          action_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 num_to_grant = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_to_grant(&has_bits);
          num_to_grant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .EEventActionScoreMode score_mode = 4 [default = k_eEventActionScoreMode_Add];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EEventActionScoreMode_IsValid(val))) {
            _internal_set_score_mode(static_cast<::EEventActionScoreMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 audit_action = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_audit_action(&has_bits);
          audit_action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 audit_data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_audit_data(&has_bits);
          audit_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgPendingEventAward::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgPendingEventAward)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event_id(), target);
  }

  // optional uint32 action_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_action_id(), target);
  }

  // optional uint32 num_to_grant = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_num_to_grant(), target);
  }

  // optional .EEventActionScoreMode score_mode = 4 [default = k_eEventActionScoreMode_Add];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_score_mode(), target);
  }

  // optional uint32 audit_action = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_audit_action(), target);
  }

  // optional uint32 audit_data = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_audit_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgPendingEventAward)
  return target;
}

size_t CMsgPendingEventAward::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgPendingEventAward)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .EEvent event_id = 1 [default = EVENT_ID_NONE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event_id());
    }

    // optional uint32 action_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_action_id());
    }

    // optional uint32 num_to_grant = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_num_to_grant());
    }

    // optional .EEventActionScoreMode score_mode = 4 [default = k_eEventActionScoreMode_Add];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_score_mode());
    }

    // optional uint32 audit_action = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_audit_action());
    }

    // optional uint32 audit_data = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_audit_data());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgPendingEventAward::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgPendingEventAward)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgPendingEventAward* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgPendingEventAward>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgPendingEventAward)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgPendingEventAward)
    MergeFrom(*source);
  }
}

void CMsgPendingEventAward::MergeFrom(const CMsgPendingEventAward& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgPendingEventAward)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      event_id_ = from.event_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      action_id_ = from.action_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_to_grant_ = from.num_to_grant_;
    }
    if (cached_has_bits & 0x00000008u) {
      score_mode_ = from.score_mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      audit_action_ = from.audit_action_;
    }
    if (cached_has_bits & 0x00000020u) {
      audit_data_ = from.audit_data_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgPendingEventAward::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgPendingEventAward)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgPendingEventAward::CopyFrom(const CMsgPendingEventAward& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgPendingEventAward)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgPendingEventAward::IsInitialized() const {
  return true;
}

void CMsgPendingEventAward::InternalSwap(CMsgPendingEventAward* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgPendingEventAward, audit_data_)
      + sizeof(CMsgPendingEventAward::audit_data_)
      - PROTOBUF_FIELD_OFFSET(CMsgPendingEventAward, event_id_)>(
          reinterpret_cast<char*>(&event_id_),
          reinterpret_cast<char*>(&other->event_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgPendingEventAward::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CDOTAClientHardwareSpecs* Arena::CreateMaybeMessage< ::CDOTAClientHardwareSpecs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTAClientHardwareSpecs >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTASaveGame_Player* Arena::CreateMaybeMessage< ::CDOTASaveGame_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTASaveGame_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTASaveGame_SaveInstance_PlayerPositions* Arena::CreateMaybeMessage< ::CDOTASaveGame_SaveInstance_PlayerPositions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTASaveGame_SaveInstance_PlayerPositions >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTASaveGame_SaveInstance* Arena::CreateMaybeMessage< ::CDOTASaveGame_SaveInstance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTASaveGame_SaveInstance >(arena);
}
template<> PROTOBUF_NOINLINE ::CDOTASaveGame* Arena::CreateMaybeMessage< ::CDOTASaveGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDOTASaveGame >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgDOTACombatLogEntry* Arena::CreateMaybeMessage< ::CMsgDOTACombatLogEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgDOTACombatLogEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgPendingEventAward* Arena::CreateMaybeMessage< ::CMsgPendingEventAward >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgPendingEventAward >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
