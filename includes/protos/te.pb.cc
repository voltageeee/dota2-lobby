// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: te.proto

#include "te.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr CMsgTEArmorRicochet::CMsgTEArmorRicochet(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pos_(nullptr)
  , dir_(nullptr){}
struct CMsgTEArmorRicochetDefaultTypeInternal {
  constexpr CMsgTEArmorRicochetDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEArmorRicochetDefaultTypeInternal() {}
  union {
    CMsgTEArmorRicochet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEArmorRicochetDefaultTypeInternal _CMsgTEArmorRicochet_default_instance_;
constexpr CMsgTEBaseBeam::CMsgTEBaseBeam(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : modelindex_(PROTOBUF_ULONGLONG(0))
  , haloindex_(PROTOBUF_ULONGLONG(0))
  , startframe_(0u)
  , framerate_(0u)
  , life_(0)
  , width_(0)
  , endwidth_(0)
  , fadelength_(0u)
  , amplitude_(0)
  , color_(0u)
  , speed_(0u)
  , flags_(0u){}
struct CMsgTEBaseBeamDefaultTypeInternal {
  constexpr CMsgTEBaseBeamDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBaseBeamDefaultTypeInternal() {}
  union {
    CMsgTEBaseBeam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBaseBeamDefaultTypeInternal _CMsgTEBaseBeam_default_instance_;
constexpr CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : base_(nullptr)
  , start_(nullptr)
  , end_(nullptr)
  , startentity_(0u)
  , endentity_(0u){}
struct CMsgTEBeamEntPointDefaultTypeInternal {
  constexpr CMsgTEBeamEntPointDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBeamEntPointDefaultTypeInternal() {}
  union {
    CMsgTEBeamEntPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBeamEntPointDefaultTypeInternal _CMsgTEBeamEntPoint_default_instance_;
constexpr CMsgTEBeamEnts::CMsgTEBeamEnts(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : base_(nullptr)
  , startentity_(0u)
  , endentity_(0u){}
struct CMsgTEBeamEntsDefaultTypeInternal {
  constexpr CMsgTEBeamEntsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBeamEntsDefaultTypeInternal() {}
  union {
    CMsgTEBeamEnts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBeamEntsDefaultTypeInternal _CMsgTEBeamEnts_default_instance_;
constexpr CMsgTEBeamPoints::CMsgTEBeamPoints(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : base_(nullptr)
  , start_(nullptr)
  , end_(nullptr){}
struct CMsgTEBeamPointsDefaultTypeInternal {
  constexpr CMsgTEBeamPointsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBeamPointsDefaultTypeInternal() {}
  union {
    CMsgTEBeamPoints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBeamPointsDefaultTypeInternal _CMsgTEBeamPoints_default_instance_;
constexpr CMsgTEBeamRing::CMsgTEBeamRing(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : base_(nullptr)
  , startentity_(0u)
  , endentity_(0u){}
struct CMsgTEBeamRingDefaultTypeInternal {
  constexpr CMsgTEBeamRingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBeamRingDefaultTypeInternal() {}
  union {
    CMsgTEBeamRing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBeamRingDefaultTypeInternal _CMsgTEBeamRing_default_instance_;
constexpr CMsgTEBSPDecal::CMsgTEBSPDecal(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , normal_(nullptr)
  , saxis_(nullptr)
  , entity_(0u)
  , index_(0u){}
struct CMsgTEBSPDecalDefaultTypeInternal {
  constexpr CMsgTEBSPDecalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBSPDecalDefaultTypeInternal() {}
  union {
    CMsgTEBSPDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBSPDecalDefaultTypeInternal _CMsgTEBSPDecal_default_instance_;
constexpr CMsgTEBubbles::CMsgTEBubbles(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mins_(nullptr)
  , maxs_(nullptr)
  , height_(0)
  , count_(0u)
  , speed_(0){}
struct CMsgTEBubblesDefaultTypeInternal {
  constexpr CMsgTEBubblesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBubblesDefaultTypeInternal() {}
  union {
    CMsgTEBubbles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBubblesDefaultTypeInternal _CMsgTEBubbles_default_instance_;
constexpr CMsgTEBubbleTrail::CMsgTEBubbleTrail(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mins_(nullptr)
  , maxs_(nullptr)
  , waterz_(0)
  , count_(0u)
  , speed_(0){}
struct CMsgTEBubbleTrailDefaultTypeInternal {
  constexpr CMsgTEBubbleTrailDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBubbleTrailDefaultTypeInternal() {}
  union {
    CMsgTEBubbleTrail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBubbleTrailDefaultTypeInternal _CMsgTEBubbleTrail_default_instance_;
constexpr CMsgTEDecal::CMsgTEDecal(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , start_(nullptr)
  , entity_(0u)
  , hitbox_(0u)
  , index_(0u){}
struct CMsgTEDecalDefaultTypeInternal {
  constexpr CMsgTEDecalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEDecalDefaultTypeInternal() {}
  union {
    CMsgTEDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEDecalDefaultTypeInternal _CMsgTEDecal_default_instance_;
constexpr CMsgEffectData::CMsgEffectData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , start_(nullptr)
  , normal_(nullptr)
  , angles_(nullptr)
  , entity_(0u)
  , otherentity_(0u)
  , scale_(0)
  , magnitude_(0)
  , radius_(0)
  , surfaceprop_(0u)
  , effectindex_(PROTOBUF_ULONGLONG(0))
  , damagetype_(0u)
  , material_(0u)
  , hitbox_(0u)
  , color_(0u)
  , flags_(0u)
  , attachmentindex_(0)
  , effectname_(0u)
  , attachmentname_(0u){}
struct CMsgEffectDataDefaultTypeInternal {
  constexpr CMsgEffectDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgEffectDataDefaultTypeInternal() {}
  union {
    CMsgEffectData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgEffectDataDefaultTypeInternal _CMsgEffectData_default_instance_;
constexpr CMsgTEEffectDispatch::CMsgTEEffectDispatch(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : effectdata_(nullptr){}
struct CMsgTEEffectDispatchDefaultTypeInternal {
  constexpr CMsgTEEffectDispatchDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEEffectDispatchDefaultTypeInternal() {}
  union {
    CMsgTEEffectDispatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEEffectDispatchDefaultTypeInternal _CMsgTEEffectDispatch_default_instance_;
constexpr CMsgTEEnergySplash::CMsgTEEnergySplash(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pos_(nullptr)
  , dir_(nullptr)
  , explosive_(false){}
struct CMsgTEEnergySplashDefaultTypeInternal {
  constexpr CMsgTEEnergySplashDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEEnergySplashDefaultTypeInternal() {}
  union {
    CMsgTEEnergySplash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEEnergySplashDefaultTypeInternal _CMsgTEEnergySplash_default_instance_;
constexpr CMsgTEFizz::CMsgTEFizz(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entity_(0u)
  , density_(0u)
  , current_(0){}
struct CMsgTEFizzDefaultTypeInternal {
  constexpr CMsgTEFizzDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEFizzDefaultTypeInternal() {}
  union {
    CMsgTEFizz _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEFizzDefaultTypeInternal _CMsgTEFizz_default_instance_;
constexpr CMsgTEShatterSurface::CMsgTEShatterSurface(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , angles_(nullptr)
  , force_(nullptr)
  , forcepos_(nullptr)
  , width_(0)
  , height_(0)
  , shardsize_(0)
  , surfacetype_(0u)
  , frontcolor_(0u)
  , backcolor_(0u){}
struct CMsgTEShatterSurfaceDefaultTypeInternal {
  constexpr CMsgTEShatterSurfaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEShatterSurfaceDefaultTypeInternal() {}
  union {
    CMsgTEShatterSurface _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEShatterSurfaceDefaultTypeInternal _CMsgTEShatterSurface_default_instance_;
constexpr CMsgTEGlowSprite::CMsgTEGlowSprite(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , scale_(0)
  , life_(0)
  , brightness_(0u){}
struct CMsgTEGlowSpriteDefaultTypeInternal {
  constexpr CMsgTEGlowSpriteDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEGlowSpriteDefaultTypeInternal() {}
  union {
    CMsgTEGlowSprite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEGlowSpriteDefaultTypeInternal _CMsgTEGlowSprite_default_instance_;
constexpr CMsgTEImpact::CMsgTEImpact(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , normal_(nullptr)
  , type_(0u){}
struct CMsgTEImpactDefaultTypeInternal {
  constexpr CMsgTEImpactDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEImpactDefaultTypeInternal() {}
  union {
    CMsgTEImpact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEImpactDefaultTypeInternal _CMsgTEImpact_default_instance_;
constexpr CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , angles_(nullptr)
  , scale_(0)
  , type_(0u){}
struct CMsgTEMuzzleFlashDefaultTypeInternal {
  constexpr CMsgTEMuzzleFlashDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEMuzzleFlashDefaultTypeInternal() {}
  union {
    CMsgTEMuzzleFlash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEMuzzleFlashDefaultTypeInternal _CMsgTEMuzzleFlash_default_instance_;
constexpr CMsgTEBloodStream::CMsgTEBloodStream(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , direction_(nullptr)
  , color_(0u)
  , amount_(0u){}
struct CMsgTEBloodStreamDefaultTypeInternal {
  constexpr CMsgTEBloodStreamDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEBloodStreamDefaultTypeInternal() {}
  union {
    CMsgTEBloodStream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEBloodStreamDefaultTypeInternal _CMsgTEBloodStream_default_instance_;
constexpr CMsgTEExplosion::CMsgTEExplosion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : effect_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , origin_(nullptr)
  , normal_(nullptr)
  , framerate_(0u)
  , flags_(0u)
  , materialtype_(0u)
  , radius_(0u)
  , magnitude_(0u)
  , scale_(0)
  , affect_ragdolls_(false)
  , explosion_type_(0u){}
struct CMsgTEExplosionDefaultTypeInternal {
  constexpr CMsgTEExplosionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEExplosionDefaultTypeInternal() {}
  union {
    CMsgTEExplosion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEExplosionDefaultTypeInternal _CMsgTEExplosion_default_instance_;
constexpr CMsgTEDust::CMsgTEDust(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , direction_(nullptr)
  , size_(0)
  , speed_(0){}
struct CMsgTEDustDefaultTypeInternal {
  constexpr CMsgTEDustDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEDustDefaultTypeInternal() {}
  union {
    CMsgTEDust _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEDustDefaultTypeInternal _CMsgTEDust_default_instance_;
constexpr CMsgTELargeFunnel::CMsgTELargeFunnel(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , reversed_(0u){}
struct CMsgTELargeFunnelDefaultTypeInternal {
  constexpr CMsgTELargeFunnelDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTELargeFunnelDefaultTypeInternal() {}
  union {
    CMsgTELargeFunnel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTELargeFunnelDefaultTypeInternal _CMsgTELargeFunnel_default_instance_;
constexpr CMsgTESparks::CMsgTESparks(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , direction_(nullptr)
  , magnitude_(0u)
  , length_(0u){}
struct CMsgTESparksDefaultTypeInternal {
  constexpr CMsgTESparksDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTESparksDefaultTypeInternal() {}
  union {
    CMsgTESparks _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTESparksDefaultTypeInternal _CMsgTESparks_default_instance_;
constexpr CMsgTEPhysicsProp::CMsgTEPhysicsProp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , velocity_(nullptr)
  , angles_(nullptr)
  , skin_(0u)
  , flags_(0u)
  , effects_(0u)
  , color_(0u)
  , modelindex_(PROTOBUF_ULONGLONG(0))
  , unused_breakmodelsnottomake_(0u)
  , scale_(0){}
struct CMsgTEPhysicsPropDefaultTypeInternal {
  constexpr CMsgTEPhysicsPropDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEPhysicsPropDefaultTypeInternal() {}
  union {
    CMsgTEPhysicsProp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEPhysicsPropDefaultTypeInternal _CMsgTEPhysicsProp_default_instance_;
constexpr CMsgTEPlayerDecal::CMsgTEPlayerDecal(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , player_(0u)
  , entity_(0u){}
struct CMsgTEPlayerDecalDefaultTypeInternal {
  constexpr CMsgTEPlayerDecalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEPlayerDecalDefaultTypeInternal() {}
  union {
    CMsgTEPlayerDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEPlayerDecalDefaultTypeInternal _CMsgTEPlayerDecal_default_instance_;
constexpr CMsgTEProjectedDecal::CMsgTEProjectedDecal(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , angles_(nullptr)
  , index_(0u)
  , distance_(0){}
struct CMsgTEProjectedDecalDefaultTypeInternal {
  constexpr CMsgTEProjectedDecalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEProjectedDecalDefaultTypeInternal() {}
  union {
    CMsgTEProjectedDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEProjectedDecalDefaultTypeInternal _CMsgTEProjectedDecal_default_instance_;
constexpr CMsgTESmoke::CMsgTESmoke(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , scale_(0){}
struct CMsgTESmokeDefaultTypeInternal {
  constexpr CMsgTESmokeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTESmokeDefaultTypeInternal() {}
  union {
    CMsgTESmoke _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTESmokeDefaultTypeInternal _CMsgTESmoke_default_instance_;
constexpr CMsgTEWorldDecal::CMsgTEWorldDecal(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : origin_(nullptr)
  , normal_(nullptr)
  , index_(0u){}
struct CMsgTEWorldDecalDefaultTypeInternal {
  constexpr CMsgTEWorldDecalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgTEWorldDecalDefaultTypeInternal() {}
  union {
    CMsgTEWorldDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgTEWorldDecalDefaultTypeInternal _CMsgTEWorldDecal_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_te_2eproto[28];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_te_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_te_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_te_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, pos_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, dir_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, modelindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, haloindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, startframe_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, framerate_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, life_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, width_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, endwidth_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, fadelength_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, amplitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, color_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, speed_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, flags_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, base_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, startentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, endentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, start_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, end_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, base_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, startentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, endentity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, base_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, start_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, end_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, base_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, startentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, endentity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, saxis_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, index_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, mins_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, maxs_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, height_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, count_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, speed_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, mins_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, maxs_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, waterz_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, count_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, speed_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, start_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, hitbox_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, index_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, start_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, otherentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, magnitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, radius_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, surfaceprop_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, effectindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, damagetype_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, material_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, hitbox_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, color_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, attachmentindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, effectname_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, attachmentname_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, effectdata_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, pos_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, dir_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, explosive_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, density_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, current_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, force_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, forcepos_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, width_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, height_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, shardsize_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, surfacetype_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, frontcolor_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, backcolor_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, life_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, brightness_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, type_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, direction_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, color_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, amount_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, framerate_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, materialtype_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, radius_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, magnitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, affect_ragdolls_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, effect_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, explosion_type_),
  1,
  3,
  4,
  2,
  5,
  6,
  7,
  8,
  9,
  0,
  10,
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, size_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, speed_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, direction_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, reversed_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, magnitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, length_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, direction_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, velocity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, skin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, effects_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, color_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, modelindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, unused_breakmodelsnottomake_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, scale_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, player_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, entity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, index_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, distance_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, scale_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, index_),
  0,
  1,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::CMsgTEArmorRicochet)},
  { 9, 26, sizeof(::CMsgTEBaseBeam)},
  { 38, 48, sizeof(::CMsgTEBeamEntPoint)},
  { 53, 61, sizeof(::CMsgTEBeamEnts)},
  { 64, 72, sizeof(::CMsgTEBeamPoints)},
  { 75, 83, sizeof(::CMsgTEBeamRing)},
  { 86, 96, sizeof(::CMsgTEBSPDecal)},
  { 101, 111, sizeof(::CMsgTEBubbles)},
  { 116, 126, sizeof(::CMsgTEBubbleTrail)},
  { 131, 141, sizeof(::CMsgTEDecal)},
  { 146, 170, sizeof(::CMsgEffectData)},
  { 189, 195, sizeof(::CMsgTEEffectDispatch)},
  { 196, 204, sizeof(::CMsgTEEnergySplash)},
  { 207, 215, sizeof(::CMsgTEFizz)},
  { 218, 233, sizeof(::CMsgTEShatterSurface)},
  { 243, 252, sizeof(::CMsgTEGlowSprite)},
  { 256, 264, sizeof(::CMsgTEImpact)},
  { 267, 276, sizeof(::CMsgTEMuzzleFlash)},
  { 280, 289, sizeof(::CMsgTEBloodStream)},
  { 293, 309, sizeof(::CMsgTEExplosion)},
  { 320, 329, sizeof(::CMsgTEDust)},
  { 333, 340, sizeof(::CMsgTELargeFunnel)},
  { 342, 351, sizeof(::CMsgTESparks)},
  { 355, 370, sizeof(::CMsgTEPhysicsProp)},
  { 380, 388, sizeof(::CMsgTEPlayerDecal)},
  { 391, 400, sizeof(::CMsgTEProjectedDecal)},
  { 404, 411, sizeof(::CMsgTESmoke)},
  { 413, 421, sizeof(::CMsgTEWorldDecal)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEArmorRicochet_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBaseBeam_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBeamEntPoint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBeamEnts_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBeamPoints_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBeamRing_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBSPDecal_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBubbles_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBubbleTrail_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEDecal_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgEffectData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEEffectDispatch_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEEnergySplash_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEFizz_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEShatterSurface_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEGlowSprite_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEImpact_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEMuzzleFlash_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEBloodStream_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEExplosion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEDust_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTELargeFunnel_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTESparks_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEPhysicsProp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEPlayerDecal_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEProjectedDecal_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTESmoke_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgTEWorldDecal_default_instance_),
};

const char descriptor_table_protodef_te_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\010te.proto\032\026networkbasetypes.proto\"I\n\023CM"
  "sgTEArmorRicochet\022\030\n\003pos\030\001 \001(\0132\013.CMsgVec"
  "tor\022\030\n\003dir\030\002 \001(\0132\013.CMsgVector\"\341\001\n\016CMsgTE"
  "BaseBeam\022\022\n\nmodelindex\030\001 \001(\006\022\021\n\thaloinde"
  "x\030\002 \001(\006\022\022\n\nstartframe\030\003 \001(\r\022\021\n\tframerate"
  "\030\004 \001(\r\022\014\n\004life\030\005 \001(\002\022\r\n\005width\030\006 \001(\002\022\020\n\010e"
  "ndwidth\030\007 \001(\002\022\022\n\nfadelength\030\010 \001(\r\022\021\n\tamp"
  "litude\030\t \001(\002\022\r\n\005color\030\n \001(\007\022\r\n\005speed\030\013 \001"
  "(\r\022\r\n\005flags\030\014 \001(\r\"\221\001\n\022CMsgTEBeamEntPoint"
  "\022\035\n\004base\030\001 \001(\0132\017.CMsgTEBaseBeam\022\023\n\013start"
  "entity\030\002 \001(\r\022\021\n\tendentity\030\003 \001(\r\022\032\n\005start"
  "\030\004 \001(\0132\013.CMsgVector\022\030\n\003end\030\005 \001(\0132\013.CMsgV"
  "ector\"W\n\016CMsgTEBeamEnts\022\035\n\004base\030\001 \001(\0132\017."
  "CMsgTEBaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\te"
  "ndentity\030\003 \001(\r\"g\n\020CMsgTEBeamPoints\022\035\n\004ba"
  "se\030\001 \001(\0132\017.CMsgTEBaseBeam\022\032\n\005start\030\002 \001(\013"
  "2\013.CMsgVector\022\030\n\003end\030\003 \001(\0132\013.CMsgVector\""
  "W\n\016CMsgTEBeamRing\022\035\n\004base\030\001 \001(\0132\017.CMsgTE"
  "BaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\tendenti"
  "ty\030\003 \001(\r\"\205\001\n\016CMsgTEBSPDecal\022\033\n\006origin\030\001 "
  "\001(\0132\013.CMsgVector\022\033\n\006normal\030\002 \001(\0132\013.CMsgV"
  "ector\022\032\n\005saxis\030\003 \001(\0132\013.CMsgVector\022\016\n\006ent"
  "ity\030\004 \001(\r\022\r\n\005index\030\005 \001(\r\"s\n\rCMsgTEBubble"
  "s\022\031\n\004mins\030\001 \001(\0132\013.CMsgVector\022\031\n\004maxs\030\002 \001"
  "(\0132\013.CMsgVector\022\016\n\006height\030\003 \001(\002\022\r\n\005count"
  "\030\004 \001(\r\022\r\n\005speed\030\005 \001(\002\"w\n\021CMsgTEBubbleTra"
  "il\022\031\n\004mins\030\001 \001(\0132\013.CMsgVector\022\031\n\004maxs\030\002 "
  "\001(\0132\013.CMsgVector\022\016\n\006waterz\030\003 \001(\002\022\r\n\005coun"
  "t\030\004 \001(\r\022\r\n\005speed\030\005 \001(\002\"u\n\013CMsgTEDecal\022\033\n"
  "\006origin\030\001 \001(\0132\013.CMsgVector\022\032\n\005start\030\002 \001("
  "\0132\013.CMsgVector\022\016\n\006entity\030\003 \001(\r\022\016\n\006hitbox"
  "\030\004 \001(\r\022\r\n\005index\030\005 \001(\r\"\235\003\n\016CMsgEffectData"
  "\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\032\n\005start\030\002"
  " \001(\0132\013.CMsgVector\022\033\n\006normal\030\003 \001(\0132\013.CMsg"
  "Vector\022\033\n\006angles\030\004 \001(\0132\013.CMsgQAngle\022\016\n\006e"
  "ntity\030\005 \001(\007\022\023\n\013otherentity\030\006 \001(\007\022\r\n\005scal"
  "e\030\007 \001(\002\022\021\n\tmagnitude\030\010 \001(\002\022\016\n\006radius\030\t \001"
  "(\002\022\023\n\013surfaceprop\030\n \001(\007\022\023\n\013effectindex\030\013"
  " \001(\006\022\022\n\ndamagetype\030\014 \001(\r\022\020\n\010material\030\r \001"
  "(\r\022\016\n\006hitbox\030\016 \001(\r\022\r\n\005color\030\017 \001(\r\022\r\n\005fla"
  "gs\030\020 \001(\r\022\027\n\017attachmentindex\030\021 \001(\005\022\022\n\neff"
  "ectname\030\022 \001(\r\022\026\n\016attachmentname\030\023 \001(\r\";\n"
  "\024CMsgTEEffectDispatch\022#\n\neffectdata\030\001 \001("
  "\0132\017.CMsgEffectData\"[\n\022CMsgTEEnergySplash"
  "\022\030\n\003pos\030\001 \001(\0132\013.CMsgVector\022\030\n\003dir\030\002 \001(\0132"
  "\013.CMsgVector\022\021\n\texplosive\030\003 \001(\010\">\n\nCMsgT"
  "EFizz\022\016\n\006entity\030\001 \001(\r\022\017\n\007density\030\002 \001(\r\022\017"
  "\n\007current\030\003 \001(\005\"\371\001\n\024CMsgTEShatterSurface"
  "\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\033\n\006angles\030"
  "\002 \001(\0132\013.CMsgQAngle\022\032\n\005force\030\003 \001(\0132\013.CMsg"
  "Vector\022\035\n\010forcepos\030\004 \001(\0132\013.CMsgVector\022\r\n"
  "\005width\030\005 \001(\002\022\016\n\006height\030\006 \001(\002\022\021\n\tshardsiz"
  "e\030\007 \001(\002\022\023\n\013surfacetype\030\010 \001(\r\022\022\n\nfrontcol"
  "or\030\t \001(\007\022\021\n\tbackcolor\030\n \001(\007\"`\n\020CMsgTEGlo"
  "wSprite\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\r\n\005"
  "scale\030\002 \001(\002\022\014\n\004life\030\003 \001(\002\022\022\n\nbrightness\030"
  "\004 \001(\r\"V\n\014CMsgTEImpact\022\033\n\006origin\030\001 \001(\0132\013."
  "CMsgVector\022\033\n\006normal\030\002 \001(\0132\013.CMsgVector\022"
  "\014\n\004type\030\003 \001(\r\"j\n\021CMsgTEMuzzleFlash\022\033\n\006or"
  "igin\030\001 \001(\0132\013.CMsgVector\022\033\n\006angles\030\002 \001(\0132"
  "\013.CMsgQAngle\022\r\n\005scale\030\003 \001(\002\022\014\n\004type\030\004 \001("
  "\r\"o\n\021CMsgTEBloodStream\022\033\n\006origin\030\001 \001(\0132\013"
  ".CMsgVector\022\036\n\tdirection\030\002 \001(\0132\013.CMsgVec"
  "tor\022\r\n\005color\030\003 \001(\007\022\016\n\006amount\030\004 \001(\r\"\373\001\n\017C"
  "MsgTEExplosion\022\033\n\006origin\030\001 \001(\0132\013.CMsgVec"
  "tor\022\021\n\tframerate\030\002 \001(\r\022\r\n\005flags\030\003 \001(\r\022\033\n"
  "\006normal\030\004 \001(\0132\013.CMsgVector\022\024\n\014materialty"
  "pe\030\005 \001(\r\022\016\n\006radius\030\006 \001(\r\022\021\n\tmagnitude\030\007 "
  "\001(\r\022\r\n\005scale\030\010 \001(\002\022\027\n\017affect_ragdolls\030\t "
  "\001(\010\022\023\n\013effect_name\030\n \001(\t\022\026\n\016explosion_ty"
  "pe\030\013 \001(\r\"f\n\nCMsgTEDust\022\033\n\006origin\030\001 \001(\0132\013"
  ".CMsgVector\022\014\n\004size\030\002 \001(\002\022\r\n\005speed\030\003 \001(\002"
  "\022\036\n\tdirection\030\004 \001(\0132\013.CMsgVector\"B\n\021CMsg"
  "TELargeFunnel\022\033\n\006origin\030\001 \001(\0132\013.CMsgVect"
  "or\022\020\n\010reversed\030\002 \001(\r\"n\n\014CMsgTESparks\022\033\n\006"
  "origin\030\001 \001(\0132\013.CMsgVector\022\021\n\tmagnitude\030\002"
  " \001(\r\022\016\n\006length\030\003 \001(\r\022\036\n\tdirection\030\004 \001(\0132"
  "\013.CMsgVector\"\361\001\n\021CMsgTEPhysicsProp\022\033\n\006or"
  "igin\030\001 \001(\0132\013.CMsgVector\022\035\n\010velocity\030\002 \001("
  "\0132\013.CMsgVector\022\033\n\006angles\030\003 \001(\0132\013.CMsgQAn"
  "gle\022\014\n\004skin\030\004 \001(\007\022\r\n\005flags\030\005 \001(\r\022\017\n\007effe"
  "cts\030\006 \001(\r\022\r\n\005color\030\007 \001(\007\022\022\n\nmodelindex\030\010"
  " \001(\006\022#\n\033unused_breakmodelsnottomake\030\t \001("
  "\r\022\r\n\005scale\030\n \001(\002\"P\n\021CMsgTEPlayerDecal\022\033\n"
  "\006origin\030\001 \001(\0132\013.CMsgVector\022\016\n\006player\030\002 \001"
  "(\r\022\016\n\006entity\030\003 \001(\r\"q\n\024CMsgTEProjectedDec"
  "al\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\033\n\006angle"
  "s\030\002 \001(\0132\013.CMsgQAngle\022\r\n\005index\030\003 \001(\r\022\020\n\010d"
  "istance\030\004 \001(\002\"9\n\013CMsgTESmoke\022\033\n\006origin\030\001"
  " \001(\0132\013.CMsgVector\022\r\n\005scale\030\002 \001(\002\"[\n\020CMsg"
  "TEWorldDecal\022\033\n\006origin\030\001 \001(\0132\013.CMsgVecto"
  "r\022\033\n\006normal\030\002 \001(\0132\013.CMsgVector\022\r\n\005index\030"
  "\003 \001(\r*\275\004\n\016ETEProtobufIds\022\030\n\023TE_EffectDis"
  "patchId\020\220\003\022\027\n\022TE_ArmorRicochetId\020\221\003\022\026\n\021T"
  "E_BeamEntPointId\020\222\003\022\022\n\rTE_BeamEntsId\020\223\003\022"
  "\024\n\017TE_BeamPointsId\020\224\003\022\022\n\rTE_BeamRingId\020\225"
  "\003\022\022\n\rTE_BSPDecalId\020\227\003\022\021\n\014TE_BubblesId\020\230\003"
  "\022\025\n\020TE_BubbleTrailId\020\231\003\022\017\n\nTE_DecalId\020\232\003"
  "\022\024\n\017TE_WorldDecalId\020\233\003\022\026\n\021TE_EnergySplas"
  "hId\020\234\003\022\016\n\tTE_FizzId\020\235\003\022\030\n\023TE_ShatterSurf"
  "aceId\020\236\003\022\024\n\017TE_GlowSpriteId\020\237\003\022\020\n\013TE_Imp"
  "actId\020\240\003\022\025\n\020TE_MuzzleFlashId\020\241\003\022\025\n\020TE_Bl"
  "oodStreamId\020\242\003\022\023\n\016TE_ExplosionId\020\243\003\022\016\n\tT"
  "E_DustId\020\244\003\022\025\n\020TE_LargeFunnelId\020\245\003\022\020\n\013TE"
  "_SparksId\020\246\003\022\025\n\020TE_PhysicsPropId\020\247\003\022\025\n\020T"
  "E_PlayerDecalId\020\250\003\022\030\n\023TE_ProjectedDecalI"
  "d\020\251\003\022\017\n\nTE_SmokeId\020\252\003B\005H\001\200\001\000"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_te_2eproto_deps[1] = {
  &::descriptor_table_networkbasetypes_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_te_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_te_2eproto = {
  false, false, 4268, descriptor_table_protodef_te_2eproto, "te.proto", 
  &descriptor_table_te_2eproto_once, descriptor_table_te_2eproto_deps, 1, 28,
  schemas, file_default_instances, TableStruct_te_2eproto::offsets,
  file_level_metadata_te_2eproto, file_level_enum_descriptors_te_2eproto, file_level_service_descriptors_te_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK ::PROTOBUF_NAMESPACE_ID::Metadata
descriptor_table_te_2eproto_metadata_getter(int index) {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_te_2eproto);
  return descriptor_table_te_2eproto.file_level_metadata[index];
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_te_2eproto(&descriptor_table_te_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETEProtobufIds_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_te_2eproto);
  return file_level_enum_descriptors_te_2eproto[0];
}
bool ETEProtobufIds_IsValid(int value) {
  switch (value) {
    case 400:
    case 401:
    case 402:
    case 403:
    case 404:
    case 405:
    case 407:
    case 408:
    case 409:
    case 410:
    case 411:
    case 412:
    case 413:
    case 414:
    case 415:
    case 416:
    case 417:
    case 418:
    case 419:
    case 420:
    case 421:
    case 422:
    case 423:
    case 424:
    case 425:
    case 426:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgTEArmorRicochet::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEArmorRicochet>()._has_bits_);
  static const ::CMsgVector& pos(const CMsgTEArmorRicochet* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& dir(const CMsgTEArmorRicochet* msg);
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTEArmorRicochet::_Internal::pos(const CMsgTEArmorRicochet* msg) {
  return *msg->pos_;
}
const ::CMsgVector&
CMsgTEArmorRicochet::_Internal::dir(const CMsgTEArmorRicochet* msg) {
  return *msg->dir_;
}
void CMsgTEArmorRicochet::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEArmorRicochet::clear_dir() {
  if (dir_ != nullptr) dir_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEArmorRicochet::CMsgTEArmorRicochet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEArmorRicochet)
}
CMsgTEArmorRicochet::CMsgTEArmorRicochet(const CMsgTEArmorRicochet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    pos_ = new ::CMsgVector(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  if (from._internal_has_dir()) {
    dir_ = new ::CMsgVector(*from.dir_);
  } else {
    dir_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CMsgTEArmorRicochet)
}

void CMsgTEArmorRicochet::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pos_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dir_) -
    reinterpret_cast<char*>(&pos_)) + sizeof(dir_));
}

CMsgTEArmorRicochet::~CMsgTEArmorRicochet() {
  // @@protoc_insertion_point(destructor:CMsgTEArmorRicochet)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEArmorRicochet::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete pos_;
  if (this != internal_default_instance()) delete dir_;
}

void CMsgTEArmorRicochet::ArenaDtor(void* object) {
  CMsgTEArmorRicochet* _this = reinterpret_cast< CMsgTEArmorRicochet* >(object);
  (void)_this;
}
void CMsgTEArmorRicochet::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEArmorRicochet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEArmorRicochet::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEArmorRicochet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pos_ != nullptr);
      pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dir_ != nullptr);
      dir_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEArmorRicochet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dir(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEArmorRicochet::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEArmorRicochet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pos(this), target, stream);
  }

  // optional .CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dir(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEArmorRicochet)
  return target;
}

size_t CMsgTEArmorRicochet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEArmorRicochet)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional .CMsgVector dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dir_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEArmorRicochet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEArmorRicochet)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEArmorRicochet* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEArmorRicochet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEArmorRicochet)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEArmorRicochet)
    MergeFrom(*source);
  }
}

void CMsgTEArmorRicochet::MergeFrom(const CMsgTEArmorRicochet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEArmorRicochet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pos()->::CMsgVector::MergeFrom(from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_dir()->::CMsgVector::MergeFrom(from._internal_dir());
    }
  }
}

void CMsgTEArmorRicochet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEArmorRicochet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEArmorRicochet::CopyFrom(const CMsgTEArmorRicochet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEArmorRicochet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEArmorRicochet::IsInitialized() const {
  return true;
}

void CMsgTEArmorRicochet::InternalSwap(CMsgTEArmorRicochet* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, dir_)
      + sizeof(CMsgTEArmorRicochet::dir_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, pos_)>(
          reinterpret_cast<char*>(&pos_),
          reinterpret_cast<char*>(&other->pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEArmorRicochet::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBaseBeam::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBaseBeam>()._has_bits_);
  static void set_has_modelindex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_haloindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_startframe(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_life(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_endwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_fadelength(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_amplitude(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

CMsgTEBaseBeam::CMsgTEBaseBeam(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBaseBeam)
}
CMsgTEBaseBeam::CMsgTEBaseBeam(const CMsgTEBaseBeam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&modelindex_, &from.modelindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&modelindex_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBaseBeam)
}

void CMsgTEBaseBeam::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&modelindex_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&modelindex_)) + sizeof(flags_));
}

CMsgTEBaseBeam::~CMsgTEBaseBeam() {
  // @@protoc_insertion_point(destructor:CMsgTEBaseBeam)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBaseBeam::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CMsgTEBaseBeam::ArenaDtor(void* object) {
  CMsgTEBaseBeam* _this = reinterpret_cast< CMsgTEBaseBeam* >(object);
  (void)_this;
}
void CMsgTEBaseBeam::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBaseBeam::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBaseBeam::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBaseBeam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&modelindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fadelength_) -
        reinterpret_cast<char*>(&modelindex_)) + sizeof(fadelength_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&amplitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&amplitude_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBaseBeam::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional fixed64 modelindex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_modelindex(&has_bits);
          modelindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional fixed64 haloindex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_haloindex(&has_bits);
          haloindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional uint32 startframe = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_startframe(&has_bits);
          startframe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 framerate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_framerate(&has_bits);
          framerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float life = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_life(&has_bits);
          life_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float width = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float endwidth = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_endwidth(&has_bits);
          endwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 fadelength = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_fadelength(&has_bits);
          fadelength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float amplitude = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_amplitude(&has_bits);
          amplitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional fixed32 color = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_color(&has_bits);
          color_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional uint32 speed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_speed(&has_bits);
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBaseBeam::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBaseBeam)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 modelindex = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_modelindex(), target);
  }

  // optional fixed64 haloindex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_haloindex(), target);
  }

  // optional uint32 startframe = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_startframe(), target);
  }

  // optional uint32 framerate = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_framerate(), target);
  }

  // optional float life = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_life(), target);
  }

  // optional float width = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_width(), target);
  }

  // optional float endwidth = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_endwidth(), target);
  }

  // optional uint32 fadelength = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_fadelength(), target);
  }

  // optional float amplitude = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_amplitude(), target);
  }

  // optional fixed32 color = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(10, this->_internal_color(), target);
  }

  // optional uint32 speed = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_speed(), target);
  }

  // optional uint32 flags = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBaseBeam)
  return target;
}

size_t CMsgTEBaseBeam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBaseBeam)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed64 modelindex = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 haloindex = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 startframe = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_startframe());
    }

    // optional uint32 framerate = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_framerate());
    }

    // optional float life = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float width = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float endwidth = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 fadelength = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_fadelength());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional float amplitude = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed32 color = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional uint32 speed = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_speed());
    }

    // optional uint32 flags = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBaseBeam::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBaseBeam)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBaseBeam* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBaseBeam>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBaseBeam)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBaseBeam)
    MergeFrom(*source);
  }
}

void CMsgTEBaseBeam::MergeFrom(const CMsgTEBaseBeam& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBaseBeam)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      modelindex_ = from.modelindex_;
    }
    if (cached_has_bits & 0x00000002u) {
      haloindex_ = from.haloindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      startframe_ = from.startframe_;
    }
    if (cached_has_bits & 0x00000008u) {
      framerate_ = from.framerate_;
    }
    if (cached_has_bits & 0x00000010u) {
      life_ = from.life_;
    }
    if (cached_has_bits & 0x00000020u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000040u) {
      endwidth_ = from.endwidth_;
    }
    if (cached_has_bits & 0x00000080u) {
      fadelength_ = from.fadelength_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      amplitude_ = from.amplitude_;
    }
    if (cached_has_bits & 0x00000200u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000400u) {
      speed_ = from.speed_;
    }
    if (cached_has_bits & 0x00000800u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBaseBeam::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBaseBeam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBaseBeam::CopyFrom(const CMsgTEBaseBeam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBaseBeam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBaseBeam::IsInitialized() const {
  return true;
}

void CMsgTEBaseBeam::InternalSwap(CMsgTEBaseBeam* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, flags_)
      + sizeof(CMsgTEBaseBeam::flags_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, modelindex_)>(
          reinterpret_cast<char*>(&modelindex_),
          reinterpret_cast<char*>(&other->modelindex_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBaseBeam::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBeamEntPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamEntPoint>()._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamEntPoint* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgVector& start(const CMsgTEBeamEntPoint* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& end(const CMsgTEBeamEntPoint* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam&
CMsgTEBeamEntPoint::_Internal::base(const CMsgTEBeamEntPoint* msg) {
  return *msg->base_;
}
const ::CMsgVector&
CMsgTEBeamEntPoint::_Internal::start(const CMsgTEBeamEntPoint* msg) {
  return *msg->start_;
}
const ::CMsgVector&
CMsgTEBeamEntPoint::_Internal::end(const CMsgTEBeamEntPoint* msg) {
  return *msg->end_;
}
void CMsgTEBeamEntPoint::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamEntPoint::clear_end() {
  if (end_ != nullptr) end_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamEntPoint)
}
CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(const CMsgTEBeamEntPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    base_ = new ::CMsgTEBaseBeam(*from.base_);
  } else {
    base_ = nullptr;
  }
  if (from._internal_has_start()) {
    start_ = new ::CMsgVector(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from._internal_has_end()) {
    end_ = new ::CMsgVector(*from.end_);
  } else {
    end_ = nullptr;
  }
  ::memcpy(&startentity_, &from.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamEntPoint)
}

void CMsgTEBeamEntPoint::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&base_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&base_)) + sizeof(endentity_));
}

CMsgTEBeamEntPoint::~CMsgTEBeamEntPoint() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamEntPoint)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBeamEntPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete base_;
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete end_;
}

void CMsgTEBeamEntPoint::ArenaDtor(void* object) {
  CMsgTEBeamEntPoint* _this = reinterpret_cast< CMsgTEBeamEntPoint* >(object);
  (void)_this;
}
void CMsgTEBeamEntPoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBeamEntPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBeamEntPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamEntPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(base_ != nullptr);
      base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(end_ != nullptr);
      end_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&endentity_) -
        reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBeamEntPoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 startentity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_startentity(&has_bits);
          startentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 endentity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_endentity(&has_bits);
          endentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector end = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBeamEntPoint::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamEntPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::base(this), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_endentity(), target);
  }

  // optional .CMsgVector start = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::start(this), target, stream);
  }

  // optional .CMsgVector end = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::end(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamEntPoint)
  return target;
}

size_t CMsgTEBeamEntPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamEntPoint)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional .CMsgVector start = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional .CMsgVector end = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *end_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_endentity());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBeamEntPoint::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBeamEntPoint)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBeamEntPoint* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBeamEntPoint>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBeamEntPoint)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBeamEntPoint)
    MergeFrom(*source);
  }
}

void CMsgTEBeamEntPoint::MergeFrom(const CMsgTEBeamEntPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamEntPoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_start()->::CMsgVector::MergeFrom(from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_end()->::CMsgVector::MergeFrom(from._internal_end());
    }
    if (cached_has_bits & 0x00000008u) {
      startentity_ = from.startentity_;
    }
    if (cached_has_bits & 0x00000010u) {
      endentity_ = from.endentity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBeamEntPoint::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBeamEntPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamEntPoint::CopyFrom(const CMsgTEBeamEntPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamEntPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamEntPoint::IsInitialized() const {
  return true;
}

void CMsgTEBeamEntPoint::InternalSwap(CMsgTEBeamEntPoint* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, endentity_)
      + sizeof(CMsgTEBeamEntPoint::endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, base_)>(
          reinterpret_cast<char*>(&base_),
          reinterpret_cast<char*>(&other->base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBeamEntPoint::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBeamEnts::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamEnts>()._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamEnts* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam&
CMsgTEBeamEnts::_Internal::base(const CMsgTEBeamEnts* msg) {
  return *msg->base_;
}
CMsgTEBeamEnts::CMsgTEBeamEnts(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamEnts)
}
CMsgTEBeamEnts::CMsgTEBeamEnts(const CMsgTEBeamEnts& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    base_ = new ::CMsgTEBaseBeam(*from.base_);
  } else {
    base_ = nullptr;
  }
  ::memcpy(&startentity_, &from.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamEnts)
}

void CMsgTEBeamEnts::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&base_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&base_)) + sizeof(endentity_));
}

CMsgTEBeamEnts::~CMsgTEBeamEnts() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamEnts)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBeamEnts::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete base_;
}

void CMsgTEBeamEnts::ArenaDtor(void* object) {
  CMsgTEBeamEnts* _this = reinterpret_cast< CMsgTEBeamEnts* >(object);
  (void)_this;
}
void CMsgTEBeamEnts::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBeamEnts::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBeamEnts::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamEnts)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(base_ != nullptr);
    base_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&endentity_) -
        reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBeamEnts::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 startentity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_startentity(&has_bits);
          startentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 endentity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_endentity(&has_bits);
          endentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBeamEnts::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamEnts)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::base(this), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_endentity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamEnts)
  return target;
}

size_t CMsgTEBeamEnts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamEnts)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_endentity());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBeamEnts::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBeamEnts)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBeamEnts* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBeamEnts>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBeamEnts)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBeamEnts)
    MergeFrom(*source);
  }
}

void CMsgTEBeamEnts::MergeFrom(const CMsgTEBeamEnts& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamEnts)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      startentity_ = from.startentity_;
    }
    if (cached_has_bits & 0x00000004u) {
      endentity_ = from.endentity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBeamEnts::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBeamEnts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamEnts::CopyFrom(const CMsgTEBeamEnts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamEnts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamEnts::IsInitialized() const {
  return true;
}

void CMsgTEBeamEnts::InternalSwap(CMsgTEBeamEnts* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, endentity_)
      + sizeof(CMsgTEBeamEnts::endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, base_)>(
          reinterpret_cast<char*>(&base_),
          reinterpret_cast<char*>(&other->base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBeamEnts::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBeamPoints::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamPoints>()._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamPoints* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgTEBeamPoints* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& end(const CMsgTEBeamPoints* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam&
CMsgTEBeamPoints::_Internal::base(const CMsgTEBeamPoints* msg) {
  return *msg->base_;
}
const ::CMsgVector&
CMsgTEBeamPoints::_Internal::start(const CMsgTEBeamPoints* msg) {
  return *msg->start_;
}
const ::CMsgVector&
CMsgTEBeamPoints::_Internal::end(const CMsgTEBeamPoints* msg) {
  return *msg->end_;
}
void CMsgTEBeamPoints::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamPoints::clear_end() {
  if (end_ != nullptr) end_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
CMsgTEBeamPoints::CMsgTEBeamPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamPoints)
}
CMsgTEBeamPoints::CMsgTEBeamPoints(const CMsgTEBeamPoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    base_ = new ::CMsgTEBaseBeam(*from.base_);
  } else {
    base_ = nullptr;
  }
  if (from._internal_has_start()) {
    start_ = new ::CMsgVector(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from._internal_has_end()) {
    end_ = new ::CMsgVector(*from.end_);
  } else {
    end_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamPoints)
}

void CMsgTEBeamPoints::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&base_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_) -
    reinterpret_cast<char*>(&base_)) + sizeof(end_));
}

CMsgTEBeamPoints::~CMsgTEBeamPoints() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamPoints)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBeamPoints::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete base_;
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete end_;
}

void CMsgTEBeamPoints::ArenaDtor(void* object) {
  CMsgTEBeamPoints* _this = reinterpret_cast< CMsgTEBeamPoints* >(object);
  (void)_this;
}
void CMsgTEBeamPoints::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBeamPoints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBeamPoints::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamPoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(base_ != nullptr);
      base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(end_ != nullptr);
      end_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBeamPoints::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBeamPoints::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamPoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::base(this), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::start(this), target, stream);
  }

  // optional .CMsgVector end = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::end(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamPoints)
  return target;
}

size_t CMsgTEBeamPoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamPoints)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional .CMsgVector end = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *end_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBeamPoints::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBeamPoints)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBeamPoints* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBeamPoints>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBeamPoints)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBeamPoints)
    MergeFrom(*source);
  }
}

void CMsgTEBeamPoints::MergeFrom(const CMsgTEBeamPoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamPoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_start()->::CMsgVector::MergeFrom(from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_end()->::CMsgVector::MergeFrom(from._internal_end());
    }
  }
}

void CMsgTEBeamPoints::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBeamPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamPoints::CopyFrom(const CMsgTEBeamPoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamPoints::IsInitialized() const {
  return true;
}

void CMsgTEBeamPoints::InternalSwap(CMsgTEBeamPoints* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, end_)
      + sizeof(CMsgTEBeamPoints::end_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, base_)>(
          reinterpret_cast<char*>(&base_),
          reinterpret_cast<char*>(&other->base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBeamPoints::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBeamRing::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamRing>()._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamRing* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam&
CMsgTEBeamRing::_Internal::base(const CMsgTEBeamRing* msg) {
  return *msg->base_;
}
CMsgTEBeamRing::CMsgTEBeamRing(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamRing)
}
CMsgTEBeamRing::CMsgTEBeamRing(const CMsgTEBeamRing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    base_ = new ::CMsgTEBaseBeam(*from.base_);
  } else {
    base_ = nullptr;
  }
  ::memcpy(&startentity_, &from.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamRing)
}

void CMsgTEBeamRing::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&base_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&endentity_) -
    reinterpret_cast<char*>(&base_)) + sizeof(endentity_));
}

CMsgTEBeamRing::~CMsgTEBeamRing() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamRing)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBeamRing::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete base_;
}

void CMsgTEBeamRing::ArenaDtor(void* object) {
  CMsgTEBeamRing* _this = reinterpret_cast< CMsgTEBeamRing* >(object);
  (void)_this;
}
void CMsgTEBeamRing::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBeamRing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBeamRing::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamRing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(base_ != nullptr);
    base_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&endentity_) -
        reinterpret_cast<char*>(&startentity_)) + sizeof(endentity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBeamRing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 startentity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_startentity(&has_bits);
          startentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 endentity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_endentity(&has_bits);
          endentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBeamRing::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamRing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::base(this), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_endentity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamRing)
  return target;
}

size_t CMsgTEBeamRing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamRing)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_endentity());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBeamRing::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBeamRing)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBeamRing* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBeamRing>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBeamRing)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBeamRing)
    MergeFrom(*source);
  }
}

void CMsgTEBeamRing::MergeFrom(const CMsgTEBeamRing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamRing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      startentity_ = from.startentity_;
    }
    if (cached_has_bits & 0x00000004u) {
      endentity_ = from.endentity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBeamRing::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBeamRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBeamRing::CopyFrom(const CMsgTEBeamRing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamRing::IsInitialized() const {
  return true;
}

void CMsgTEBeamRing::InternalSwap(CMsgTEBeamRing* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, endentity_)
      + sizeof(CMsgTEBeamRing::endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, base_)>(
          reinterpret_cast<char*>(&base_),
          reinterpret_cast<char*>(&other->base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBeamRing::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBSPDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBSPDecal>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEBSPDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEBSPDecal* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& saxis(const CMsgTEBSPDecal* msg);
  static void set_has_saxis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector&
CMsgTEBSPDecal::_Internal::origin(const CMsgTEBSPDecal* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTEBSPDecal::_Internal::normal(const CMsgTEBSPDecal* msg) {
  return *msg->normal_;
}
const ::CMsgVector&
CMsgTEBSPDecal::_Internal::saxis(const CMsgTEBSPDecal* msg) {
  return *msg->saxis_;
}
void CMsgTEBSPDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBSPDecal::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBSPDecal::clear_saxis() {
  if (saxis_ != nullptr) saxis_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
CMsgTEBSPDecal::CMsgTEBSPDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBSPDecal)
}
CMsgTEBSPDecal::CMsgTEBSPDecal(const CMsgTEBSPDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_normal()) {
    normal_ = new ::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  if (from._internal_has_saxis()) {
    saxis_ = new ::CMsgVector(*from.saxis_);
  } else {
    saxis_ = nullptr;
  }
  ::memcpy(&entity_, &from.entity_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBSPDecal)
}

void CMsgTEBSPDecal::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(index_));
}

CMsgTEBSPDecal::~CMsgTEBSPDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEBSPDecal)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBSPDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete normal_;
  if (this != internal_default_instance()) delete saxis_;
}

void CMsgTEBSPDecal::ArenaDtor(void* object) {
  CMsgTEBSPDecal* _this = reinterpret_cast< CMsgTEBSPDecal* >(object);
  (void)_this;
}
void CMsgTEBSPDecal::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBSPDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBSPDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBSPDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(saxis_ != nullptr);
      saxis_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&entity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&entity_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBSPDecal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector saxis = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_saxis(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 entity = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_entity(&has_bits);
          entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBSPDecal::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBSPDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::normal(this), target, stream);
  }

  // optional .CMsgVector saxis = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::saxis(this), target, stream);
  }

  // optional uint32 entity = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_entity(), target);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBSPDecal)
  return target;
}

size_t CMsgTEBSPDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBSPDecal)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional .CMsgVector saxis = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *saxis_);
    }

    // optional uint32 entity = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_entity());
    }

    // optional uint32 index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBSPDecal::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBSPDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBSPDecal* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBSPDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBSPDecal)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBSPDecal)
    MergeFrom(*source);
  }
}

void CMsgTEBSPDecal::MergeFrom(const CMsgTEBSPDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBSPDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_normal()->::CMsgVector::MergeFrom(from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_saxis()->::CMsgVector::MergeFrom(from._internal_saxis());
    }
    if (cached_has_bits & 0x00000008u) {
      entity_ = from.entity_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBSPDecal::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBSPDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBSPDecal::CopyFrom(const CMsgTEBSPDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBSPDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBSPDecal::IsInitialized() const {
  return true;
}

void CMsgTEBSPDecal::InternalSwap(CMsgTEBSPDecal* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, index_)
      + sizeof(CMsgTEBSPDecal::index_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBSPDecal::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBubbles::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBubbles>()._has_bits_);
  static const ::CMsgVector& mins(const CMsgTEBubbles* msg);
  static void set_has_mins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& maxs(const CMsgTEBubbles* msg);
  static void set_has_maxs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector&
CMsgTEBubbles::_Internal::mins(const CMsgTEBubbles* msg) {
  return *msg->mins_;
}
const ::CMsgVector&
CMsgTEBubbles::_Internal::maxs(const CMsgTEBubbles* msg) {
  return *msg->maxs_;
}
void CMsgTEBubbles::clear_mins() {
  if (mins_ != nullptr) mins_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbles::clear_maxs() {
  if (maxs_ != nullptr) maxs_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEBubbles::CMsgTEBubbles(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBubbles)
}
CMsgTEBubbles::CMsgTEBubbles(const CMsgTEBubbles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_mins()) {
    mins_ = new ::CMsgVector(*from.mins_);
  } else {
    mins_ = nullptr;
  }
  if (from._internal_has_maxs()) {
    maxs_ = new ::CMsgVector(*from.maxs_);
  } else {
    maxs_ = nullptr;
  }
  ::memcpy(&height_, &from.height_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&height_)) + sizeof(speed_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBubbles)
}

void CMsgTEBubbles::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mins_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&mins_)) + sizeof(speed_));
}

CMsgTEBubbles::~CMsgTEBubbles() {
  // @@protoc_insertion_point(destructor:CMsgTEBubbles)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBubbles::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete mins_;
  if (this != internal_default_instance()) delete maxs_;
}

void CMsgTEBubbles::ArenaDtor(void* object) {
  CMsgTEBubbles* _this = reinterpret_cast< CMsgTEBubbles* >(object);
  (void)_this;
}
void CMsgTEBubbles::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBubbles::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBubbles::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBubbles)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(mins_ != nullptr);
      mins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(maxs_ != nullptr);
      maxs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&height_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&height_)) + sizeof(speed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBubbles::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector mins = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mins(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector maxs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_maxs(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_speed(&has_bits);
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBubbles::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBubbles)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::mins(this), target, stream);
  }

  // optional .CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::maxs(this), target, stream);
  }

  // optional float height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_height(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBubbles)
  return target;
}

size_t CMsgTEBubbles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBubbles)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector mins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mins_);
    }

    // optional .CMsgVector maxs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *maxs_);
    }

    // optional float height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_count());
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBubbles::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBubbles)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBubbles* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBubbles>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBubbles)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBubbles)
    MergeFrom(*source);
  }
}

void CMsgTEBubbles::MergeFrom(const CMsgTEBubbles& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBubbles)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_mins()->::CMsgVector::MergeFrom(from._internal_mins());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_maxs()->::CMsgVector::MergeFrom(from._internal_maxs());
    }
    if (cached_has_bits & 0x00000004u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      speed_ = from.speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBubbles::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBubbles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBubbles::CopyFrom(const CMsgTEBubbles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBubbles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBubbles::IsInitialized() const {
  return true;
}

void CMsgTEBubbles::InternalSwap(CMsgTEBubbles* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, speed_)
      + sizeof(CMsgTEBubbles::speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, mins_)>(
          reinterpret_cast<char*>(&mins_),
          reinterpret_cast<char*>(&other->mins_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBubbles::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBubbleTrail::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBubbleTrail>()._has_bits_);
  static const ::CMsgVector& mins(const CMsgTEBubbleTrail* msg);
  static void set_has_mins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& maxs(const CMsgTEBubbleTrail* msg);
  static void set_has_maxs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_waterz(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector&
CMsgTEBubbleTrail::_Internal::mins(const CMsgTEBubbleTrail* msg) {
  return *msg->mins_;
}
const ::CMsgVector&
CMsgTEBubbleTrail::_Internal::maxs(const CMsgTEBubbleTrail* msg) {
  return *msg->maxs_;
}
void CMsgTEBubbleTrail::clear_mins() {
  if (mins_ != nullptr) mins_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbleTrail::clear_maxs() {
  if (maxs_ != nullptr) maxs_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEBubbleTrail::CMsgTEBubbleTrail(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBubbleTrail)
}
CMsgTEBubbleTrail::CMsgTEBubbleTrail(const CMsgTEBubbleTrail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_mins()) {
    mins_ = new ::CMsgVector(*from.mins_);
  } else {
    mins_ = nullptr;
  }
  if (from._internal_has_maxs()) {
    maxs_ = new ::CMsgVector(*from.maxs_);
  } else {
    maxs_ = nullptr;
  }
  ::memcpy(&waterz_, &from.waterz_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&waterz_)) + sizeof(speed_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBubbleTrail)
}

void CMsgTEBubbleTrail::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mins_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&mins_)) + sizeof(speed_));
}

CMsgTEBubbleTrail::~CMsgTEBubbleTrail() {
  // @@protoc_insertion_point(destructor:CMsgTEBubbleTrail)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBubbleTrail::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete mins_;
  if (this != internal_default_instance()) delete maxs_;
}

void CMsgTEBubbleTrail::ArenaDtor(void* object) {
  CMsgTEBubbleTrail* _this = reinterpret_cast< CMsgTEBubbleTrail* >(object);
  (void)_this;
}
void CMsgTEBubbleTrail::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBubbleTrail::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBubbleTrail::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBubbleTrail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(mins_ != nullptr);
      mins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(maxs_ != nullptr);
      maxs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&waterz_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&waterz_)) + sizeof(speed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBubbleTrail::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector mins = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mins(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector maxs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_maxs(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float waterz = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_waterz(&has_bits);
          waterz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_speed(&has_bits);
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBubbleTrail::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBubbleTrail)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::mins(this), target, stream);
  }

  // optional .CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::maxs(this), target, stream);
  }

  // optional float waterz = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_waterz(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBubbleTrail)
  return target;
}

size_t CMsgTEBubbleTrail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBubbleTrail)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector mins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mins_);
    }

    // optional .CMsgVector maxs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *maxs_);
    }

    // optional float waterz = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_count());
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBubbleTrail::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBubbleTrail)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBubbleTrail* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBubbleTrail>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBubbleTrail)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBubbleTrail)
    MergeFrom(*source);
  }
}

void CMsgTEBubbleTrail::MergeFrom(const CMsgTEBubbleTrail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBubbleTrail)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_mins()->::CMsgVector::MergeFrom(from._internal_mins());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_maxs()->::CMsgVector::MergeFrom(from._internal_maxs());
    }
    if (cached_has_bits & 0x00000004u) {
      waterz_ = from.waterz_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      speed_ = from.speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBubbleTrail::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBubbleTrail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBubbleTrail::CopyFrom(const CMsgTEBubbleTrail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBubbleTrail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBubbleTrail::IsInitialized() const {
  return true;
}

void CMsgTEBubbleTrail::InternalSwap(CMsgTEBubbleTrail* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, speed_)
      + sizeof(CMsgTEBubbleTrail::speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, mins_)>(
          reinterpret_cast<char*>(&mins_),
          reinterpret_cast<char*>(&other->mins_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBubbleTrail::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEDecal>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgTEDecal* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hitbox(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector&
CMsgTEDecal::_Internal::origin(const CMsgTEDecal* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTEDecal::_Internal::start(const CMsgTEDecal* msg) {
  return *msg->start_;
}
void CMsgTEDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDecal::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEDecal::CMsgTEDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEDecal)
}
CMsgTEDecal::CMsgTEDecal(const CMsgTEDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_start()) {
    start_ = new ::CMsgVector(*from.start_);
  } else {
    start_ = nullptr;
  }
  ::memcpy(&entity_, &from.entity_,
    static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(index_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEDecal)
}

void CMsgTEDecal::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(index_));
}

CMsgTEDecal::~CMsgTEDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEDecal)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete start_;
}

void CMsgTEDecal::ArenaDtor(void* object) {
  CMsgTEDecal* _this = reinterpret_cast< CMsgTEDecal* >(object);
  (void)_this;
}
void CMsgTEDecal::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&entity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_) -
        reinterpret_cast<char*>(&entity_)) + sizeof(index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEDecal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 entity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_entity(&has_bits);
          entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 hitbox = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_hitbox(&has_bits);
          hitbox_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEDecal::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::start(this), target, stream);
  }

  // optional uint32 entity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_entity(), target);
  }

  // optional uint32 hitbox = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_hitbox(), target);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEDecal)
  return target;
}

size_t CMsgTEDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEDecal)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional uint32 entity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_entity());
    }

    // optional uint32 hitbox = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_hitbox());
    }

    // optional uint32 index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEDecal::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEDecal* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEDecal)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEDecal)
    MergeFrom(*source);
  }
}

void CMsgTEDecal::MergeFrom(const CMsgTEDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_start()->::CMsgVector::MergeFrom(from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      entity_ = from.entity_;
    }
    if (cached_has_bits & 0x00000008u) {
      hitbox_ = from.hitbox_;
    }
    if (cached_has_bits & 0x00000010u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEDecal::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEDecal::CopyFrom(const CMsgTEDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEDecal::IsInitialized() const {
  return true;
}

void CMsgTEDecal::InternalSwap(CMsgTEDecal* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEDecal, index_)
      + sizeof(CMsgTEDecal::index_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEDecal, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEDecal::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgEffectData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgEffectData>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgEffectData* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgEffectData* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& normal(const CMsgEffectData* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgQAngle& angles(const CMsgEffectData* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_otherentity(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_surfaceprop(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_effectindex(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_damagetype(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_material(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_hitbox(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_attachmentindex(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_effectname(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_attachmentname(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
};

const ::CMsgVector&
CMsgEffectData::_Internal::origin(const CMsgEffectData* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgEffectData::_Internal::start(const CMsgEffectData* msg) {
  return *msg->start_;
}
const ::CMsgVector&
CMsgEffectData::_Internal::normal(const CMsgEffectData* msg) {
  return *msg->normal_;
}
const ::CMsgQAngle&
CMsgEffectData::_Internal::angles(const CMsgEffectData* msg) {
  return *msg->angles_;
}
void CMsgEffectData::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgEffectData::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgEffectData::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgEffectData::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
CMsgEffectData::CMsgEffectData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgEffectData)
}
CMsgEffectData::CMsgEffectData(const CMsgEffectData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_start()) {
    start_ = new ::CMsgVector(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from._internal_has_normal()) {
    normal_ = new ::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  if (from._internal_has_angles()) {
    angles_ = new ::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  ::memcpy(&entity_, &from.entity_,
    static_cast<size_t>(reinterpret_cast<char*>(&attachmentname_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(attachmentname_));
  // @@protoc_insertion_point(copy_constructor:CMsgEffectData)
}

void CMsgEffectData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&attachmentname_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(attachmentname_));
}

CMsgEffectData::~CMsgEffectData() {
  // @@protoc_insertion_point(destructor:CMsgEffectData)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgEffectData::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete normal_;
  if (this != internal_default_instance()) delete angles_;
}

void CMsgEffectData::ArenaDtor(void* object) {
  CMsgEffectData* _this = reinterpret_cast< CMsgEffectData* >(object);
  (void)_this;
}
void CMsgEffectData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgEffectData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgEffectData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgEffectData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&entity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&magnitude_) -
        reinterpret_cast<char*>(&entity_)) + sizeof(magnitude_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&radius_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&radius_)) + sizeof(flags_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&attachmentindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&attachmentname_) -
        reinterpret_cast<char*>(&attachmentindex_)) + sizeof(attachmentname_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgEffectData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional fixed32 entity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_entity(&has_bits);
          entity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional fixed32 otherentity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_otherentity(&has_bits);
          otherentity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional float scale = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float magnitude = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_magnitude(&has_bits);
          magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float radius = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional fixed32 surfaceprop = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_surfaceprop(&has_bits);
          surfaceprop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional fixed64 effectindex = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 89)) {
          _Internal::set_has_effectindex(&has_bits);
          effectindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional uint32 damagetype = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_damagetype(&has_bits);
          damagetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 material = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_material(&has_bits);
          material_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 hitbox = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_hitbox(&has_bits);
          hitbox_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 color = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_color(&has_bits);
          color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 attachmentindex = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_attachmentindex(&has_bits);
          attachmentindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 effectname = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_effectname(&has_bits);
          effectname_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 attachmentname = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_attachmentname(&has_bits);
          attachmentname_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgEffectData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgEffectData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::start(this), target, stream);
  }

  // optional .CMsgVector normal = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::normal(this), target, stream);
  }

  // optional .CMsgQAngle angles = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::angles(this), target, stream);
  }

  // optional fixed32 entity = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(5, this->_internal_entity(), target);
  }

  // optional fixed32 otherentity = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(6, this->_internal_otherentity(), target);
  }

  // optional float scale = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_scale(), target);
  }

  // optional float magnitude = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_magnitude(), target);
  }

  // optional float radius = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_radius(), target);
  }

  // optional fixed32 surfaceprop = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(10, this->_internal_surfaceprop(), target);
  }

  // optional fixed64 effectindex = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(11, this->_internal_effectindex(), target);
  }

  // optional uint32 damagetype = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_damagetype(), target);
  }

  // optional uint32 material = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_material(), target);
  }

  // optional uint32 hitbox = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(14, this->_internal_hitbox(), target);
  }

  // optional uint32 color = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(15, this->_internal_color(), target);
  }

  // optional uint32 flags = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(16, this->_internal_flags(), target);
  }

  // optional int32 attachmentindex = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(17, this->_internal_attachmentindex(), target);
  }

  // optional uint32 effectname = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(18, this->_internal_effectname(), target);
  }

  // optional uint32 attachmentname = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(19, this->_internal_attachmentname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgEffectData)
  return target;
}

size_t CMsgEffectData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgEffectData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional .CMsgVector normal = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional .CMsgQAngle angles = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional fixed32 entity = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional fixed32 otherentity = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float scale = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float magnitude = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float radius = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed32 surfaceprop = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional fixed64 effectindex = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional uint32 damagetype = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_damagetype());
    }

    // optional uint32 material = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_material());
    }

    // optional uint32 hitbox = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_hitbox());
    }

    // optional uint32 color = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_color());
    }

    // optional uint32 flags = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional int32 attachmentindex = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_attachmentindex());
    }

    // optional uint32 effectname = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_effectname());
    }

    // optional uint32 attachmentname = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_attachmentname());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgEffectData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgEffectData)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgEffectData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgEffectData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgEffectData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgEffectData)
    MergeFrom(*source);
  }
}

void CMsgEffectData::MergeFrom(const CMsgEffectData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgEffectData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_start()->::CMsgVector::MergeFrom(from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_normal()->::CMsgVector::MergeFrom(from._internal_normal());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_angles()->::CMsgQAngle::MergeFrom(from._internal_angles());
    }
    if (cached_has_bits & 0x00000010u) {
      entity_ = from.entity_;
    }
    if (cached_has_bits & 0x00000020u) {
      otherentity_ = from.otherentity_;
    }
    if (cached_has_bits & 0x00000040u) {
      scale_ = from.scale_;
    }
    if (cached_has_bits & 0x00000080u) {
      magnitude_ = from.magnitude_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00000200u) {
      surfaceprop_ = from.surfaceprop_;
    }
    if (cached_has_bits & 0x00000400u) {
      effectindex_ = from.effectindex_;
    }
    if (cached_has_bits & 0x00000800u) {
      damagetype_ = from.damagetype_;
    }
    if (cached_has_bits & 0x00001000u) {
      material_ = from.material_;
    }
    if (cached_has_bits & 0x00002000u) {
      hitbox_ = from.hitbox_;
    }
    if (cached_has_bits & 0x00004000u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00008000u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      attachmentindex_ = from.attachmentindex_;
    }
    if (cached_has_bits & 0x00020000u) {
      effectname_ = from.effectname_;
    }
    if (cached_has_bits & 0x00040000u) {
      attachmentname_ = from.attachmentname_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgEffectData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgEffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgEffectData::CopyFrom(const CMsgEffectData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgEffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgEffectData::IsInitialized() const {
  return true;
}

void CMsgEffectData::InternalSwap(CMsgEffectData* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgEffectData, attachmentname_)
      + sizeof(CMsgEffectData::attachmentname_)
      - PROTOBUF_FIELD_OFFSET(CMsgEffectData, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgEffectData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEEffectDispatch::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEEffectDispatch>()._has_bits_);
  static const ::CMsgEffectData& effectdata(const CMsgTEEffectDispatch* msg);
  static void set_has_effectdata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgEffectData&
CMsgTEEffectDispatch::_Internal::effectdata(const CMsgTEEffectDispatch* msg) {
  return *msg->effectdata_;
}
CMsgTEEffectDispatch::CMsgTEEffectDispatch(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEEffectDispatch)
}
CMsgTEEffectDispatch::CMsgTEEffectDispatch(const CMsgTEEffectDispatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_effectdata()) {
    effectdata_ = new ::CMsgEffectData(*from.effectdata_);
  } else {
    effectdata_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CMsgTEEffectDispatch)
}

void CMsgTEEffectDispatch::SharedCtor() {
effectdata_ = nullptr;
}

CMsgTEEffectDispatch::~CMsgTEEffectDispatch() {
  // @@protoc_insertion_point(destructor:CMsgTEEffectDispatch)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEEffectDispatch::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete effectdata_;
}

void CMsgTEEffectDispatch::ArenaDtor(void* object) {
  CMsgTEEffectDispatch* _this = reinterpret_cast< CMsgTEEffectDispatch* >(object);
  (void)_this;
}
void CMsgTEEffectDispatch::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEEffectDispatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEEffectDispatch::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEEffectDispatch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(effectdata_ != nullptr);
    effectdata_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEEffectDispatch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgEffectData effectdata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_effectdata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEEffectDispatch::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEEffectDispatch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgEffectData effectdata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::effectdata(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEEffectDispatch)
  return target;
}

size_t CMsgTEEffectDispatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEEffectDispatch)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgEffectData effectdata = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *effectdata_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEEffectDispatch::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEEffectDispatch)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEEffectDispatch* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEEffectDispatch>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEEffectDispatch)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEEffectDispatch)
    MergeFrom(*source);
  }
}

void CMsgTEEffectDispatch::MergeFrom(const CMsgTEEffectDispatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEEffectDispatch)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_effectdata()) {
    _internal_mutable_effectdata()->::CMsgEffectData::MergeFrom(from._internal_effectdata());
  }
}

void CMsgTEEffectDispatch::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEEffectDispatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEEffectDispatch::CopyFrom(const CMsgTEEffectDispatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEEffectDispatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEEffectDispatch::IsInitialized() const {
  return true;
}

void CMsgTEEffectDispatch::InternalSwap(CMsgTEEffectDispatch* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(effectdata_, other->effectdata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEEffectDispatch::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEEnergySplash::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEEnergySplash>()._has_bits_);
  static const ::CMsgVector& pos(const CMsgTEEnergySplash* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& dir(const CMsgTEEnergySplash* msg);
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_explosive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector&
CMsgTEEnergySplash::_Internal::pos(const CMsgTEEnergySplash* msg) {
  return *msg->pos_;
}
const ::CMsgVector&
CMsgTEEnergySplash::_Internal::dir(const CMsgTEEnergySplash* msg) {
  return *msg->dir_;
}
void CMsgTEEnergySplash::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEEnergySplash::clear_dir() {
  if (dir_ != nullptr) dir_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEEnergySplash::CMsgTEEnergySplash(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEEnergySplash)
}
CMsgTEEnergySplash::CMsgTEEnergySplash(const CMsgTEEnergySplash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    pos_ = new ::CMsgVector(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  if (from._internal_has_dir()) {
    dir_ = new ::CMsgVector(*from.dir_);
  } else {
    dir_ = nullptr;
  }
  explosive_ = from.explosive_;
  // @@protoc_insertion_point(copy_constructor:CMsgTEEnergySplash)
}

void CMsgTEEnergySplash::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pos_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&explosive_) -
    reinterpret_cast<char*>(&pos_)) + sizeof(explosive_));
}

CMsgTEEnergySplash::~CMsgTEEnergySplash() {
  // @@protoc_insertion_point(destructor:CMsgTEEnergySplash)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEEnergySplash::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete pos_;
  if (this != internal_default_instance()) delete dir_;
}

void CMsgTEEnergySplash::ArenaDtor(void* object) {
  CMsgTEEnergySplash* _this = reinterpret_cast< CMsgTEEnergySplash* >(object);
  (void)_this;
}
void CMsgTEEnergySplash::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEEnergySplash::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEEnergySplash::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEEnergySplash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pos_ != nullptr);
      pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dir_ != nullptr);
      dir_->Clear();
    }
  }
  explosive_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEEnergySplash::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dir(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool explosive = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_explosive(&has_bits);
          explosive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEEnergySplash::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEEnergySplash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pos(this), target, stream);
  }

  // optional .CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::dir(this), target, stream);
  }

  // optional bool explosive = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_explosive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEEnergySplash)
  return target;
}

size_t CMsgTEEnergySplash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEEnergySplash)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional .CMsgVector dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dir_);
    }

    // optional bool explosive = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEEnergySplash::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEEnergySplash)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEEnergySplash* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEEnergySplash>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEEnergySplash)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEEnergySplash)
    MergeFrom(*source);
  }
}

void CMsgTEEnergySplash::MergeFrom(const CMsgTEEnergySplash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEEnergySplash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pos()->::CMsgVector::MergeFrom(from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_dir()->::CMsgVector::MergeFrom(from._internal_dir());
    }
    if (cached_has_bits & 0x00000004u) {
      explosive_ = from.explosive_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEEnergySplash::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEEnergySplash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEEnergySplash::CopyFrom(const CMsgTEEnergySplash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEEnergySplash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEEnergySplash::IsInitialized() const {
  return true;
}

void CMsgTEEnergySplash::InternalSwap(CMsgTEEnergySplash* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, explosive_)
      + sizeof(CMsgTEEnergySplash::explosive_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, pos_)>(
          reinterpret_cast<char*>(&pos_),
          reinterpret_cast<char*>(&other->pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEEnergySplash::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEFizz::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEFizz>()._has_bits_);
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_density(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_current(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgTEFizz::CMsgTEFizz(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEFizz)
}
CMsgTEFizz::CMsgTEFizz(const CMsgTEFizz& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&entity_, &from.entity_,
    static_cast<size_t>(reinterpret_cast<char*>(&current_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(current_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEFizz)
}

void CMsgTEFizz::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&entity_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&current_) -
    reinterpret_cast<char*>(&entity_)) + sizeof(current_));
}

CMsgTEFizz::~CMsgTEFizz() {
  // @@protoc_insertion_point(destructor:CMsgTEFizz)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEFizz::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void CMsgTEFizz::ArenaDtor(void* object) {
  CMsgTEFizz* _this = reinterpret_cast< CMsgTEFizz* >(object);
  (void)_this;
}
void CMsgTEFizz::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEFizz::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEFizz::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEFizz)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&entity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_) -
        reinterpret_cast<char*>(&entity_)) + sizeof(current_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEFizz::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint32 entity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_entity(&has_bits);
          entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 density = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_density(&has_bits);
          density_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 current = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_current(&has_bits);
          current_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEFizz::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEFizz)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 entity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_entity(), target);
  }

  // optional uint32 density = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_density(), target);
  }

  // optional int32 current = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_current(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEFizz)
  return target;
}

size_t CMsgTEFizz::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEFizz)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 entity = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_entity());
    }

    // optional uint32 density = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_density());
    }

    // optional int32 current = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_current());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEFizz::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEFizz)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEFizz* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEFizz>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEFizz)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEFizz)
    MergeFrom(*source);
  }
}

void CMsgTEFizz::MergeFrom(const CMsgTEFizz& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEFizz)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      entity_ = from.entity_;
    }
    if (cached_has_bits & 0x00000002u) {
      density_ = from.density_;
    }
    if (cached_has_bits & 0x00000004u) {
      current_ = from.current_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEFizz::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEFizz)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEFizz::CopyFrom(const CMsgTEFizz& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEFizz)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEFizz::IsInitialized() const {
  return true;
}

void CMsgTEFizz::InternalSwap(CMsgTEFizz* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEFizz, current_)
      + sizeof(CMsgTEFizz::current_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEFizz, entity_)>(
          reinterpret_cast<char*>(&entity_),
          reinterpret_cast<char*>(&other->entity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEFizz::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEShatterSurface::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEShatterSurface>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEShatterSurface* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEShatterSurface* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& force(const CMsgTEShatterSurface* msg);
  static void set_has_force(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVector& forcepos(const CMsgTEShatterSurface* msg);
  static void set_has_forcepos(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shardsize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_surfacetype(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_frontcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_backcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::CMsgVector&
CMsgTEShatterSurface::_Internal::origin(const CMsgTEShatterSurface* msg) {
  return *msg->origin_;
}
const ::CMsgQAngle&
CMsgTEShatterSurface::_Internal::angles(const CMsgTEShatterSurface* msg) {
  return *msg->angles_;
}
const ::CMsgVector&
CMsgTEShatterSurface::_Internal::force(const CMsgTEShatterSurface* msg) {
  return *msg->force_;
}
const ::CMsgVector&
CMsgTEShatterSurface::_Internal::forcepos(const CMsgTEShatterSurface* msg) {
  return *msg->forcepos_;
}
void CMsgTEShatterSurface::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEShatterSurface::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEShatterSurface::clear_force() {
  if (force_ != nullptr) force_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void CMsgTEShatterSurface::clear_forcepos() {
  if (forcepos_ != nullptr) forcepos_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
CMsgTEShatterSurface::CMsgTEShatterSurface(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEShatterSurface)
}
CMsgTEShatterSurface::CMsgTEShatterSurface(const CMsgTEShatterSurface& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_angles()) {
    angles_ = new ::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  if (from._internal_has_force()) {
    force_ = new ::CMsgVector(*from.force_);
  } else {
    force_ = nullptr;
  }
  if (from._internal_has_forcepos()) {
    forcepos_ = new ::CMsgVector(*from.forcepos_);
  } else {
    forcepos_ = nullptr;
  }
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&backcolor_) -
    reinterpret_cast<char*>(&width_)) + sizeof(backcolor_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEShatterSurface)
}

void CMsgTEShatterSurface::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&backcolor_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(backcolor_));
}

CMsgTEShatterSurface::~CMsgTEShatterSurface() {
  // @@protoc_insertion_point(destructor:CMsgTEShatterSurface)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEShatterSurface::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete angles_;
  if (this != internal_default_instance()) delete force_;
  if (this != internal_default_instance()) delete forcepos_;
}

void CMsgTEShatterSurface::ArenaDtor(void* object) {
  CMsgTEShatterSurface* _this = reinterpret_cast< CMsgTEShatterSurface* >(object);
  (void)_this;
}
void CMsgTEShatterSurface::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEShatterSurface::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEShatterSurface::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEShatterSurface)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(force_ != nullptr);
      force_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(forcepos_ != nullptr);
      forcepos_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&surfacetype_) -
        reinterpret_cast<char*>(&width_)) + sizeof(surfacetype_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&frontcolor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&backcolor_) -
        reinterpret_cast<char*>(&frontcolor_)) + sizeof(backcolor_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEShatterSurface::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector force = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_force(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector forcepos = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_forcepos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float width = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float height = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float shardsize = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_shardsize(&has_bits);
          shardsize_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 surfacetype = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_surfacetype(&has_bits);
          surfacetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional fixed32 frontcolor = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_frontcolor(&has_bits);
          frontcolor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional fixed32 backcolor = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_backcolor(&has_bits);
          backcolor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEShatterSurface::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEShatterSurface)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::angles(this), target, stream);
  }

  // optional .CMsgVector force = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::force(this), target, stream);
  }

  // optional .CMsgVector forcepos = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::forcepos(this), target, stream);
  }

  // optional float width = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_width(), target);
  }

  // optional float height = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_height(), target);
  }

  // optional float shardsize = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_shardsize(), target);
  }

  // optional uint32 surfacetype = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_surfacetype(), target);
  }

  // optional fixed32 frontcolor = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(9, this->_internal_frontcolor(), target);
  }

  // optional fixed32 backcolor = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(10, this->_internal_backcolor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEShatterSurface)
  return target;
}

size_t CMsgTEShatterSurface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEShatterSurface)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional .CMsgVector force = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *force_);
    }

    // optional .CMsgVector forcepos = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *forcepos_);
    }

    // optional float width = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float height = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float shardsize = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 surfacetype = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_surfacetype());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional fixed32 frontcolor = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed32 backcolor = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEShatterSurface::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEShatterSurface)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEShatterSurface* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEShatterSurface>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEShatterSurface)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEShatterSurface)
    MergeFrom(*source);
  }
}

void CMsgTEShatterSurface::MergeFrom(const CMsgTEShatterSurface& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEShatterSurface)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_angles()->::CMsgQAngle::MergeFrom(from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_force()->::CMsgVector::MergeFrom(from._internal_force());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_forcepos()->::CMsgVector::MergeFrom(from._internal_forcepos());
    }
    if (cached_has_bits & 0x00000010u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000020u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000040u) {
      shardsize_ = from.shardsize_;
    }
    if (cached_has_bits & 0x00000080u) {
      surfacetype_ = from.surfacetype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      frontcolor_ = from.frontcolor_;
    }
    if (cached_has_bits & 0x00000200u) {
      backcolor_ = from.backcolor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEShatterSurface::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEShatterSurface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEShatterSurface::CopyFrom(const CMsgTEShatterSurface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEShatterSurface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEShatterSurface::IsInitialized() const {
  return true;
}

void CMsgTEShatterSurface::InternalSwap(CMsgTEShatterSurface* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, backcolor_)
      + sizeof(CMsgTEShatterSurface::backcolor_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEShatterSurface::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEGlowSprite::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEGlowSprite>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEGlowSprite* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_life(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_brightness(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEGlowSprite::_Internal::origin(const CMsgTEGlowSprite* msg) {
  return *msg->origin_;
}
void CMsgTEGlowSprite::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
CMsgTEGlowSprite::CMsgTEGlowSprite(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEGlowSprite)
}
CMsgTEGlowSprite::CMsgTEGlowSprite(const CMsgTEGlowSprite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  ::memcpy(&scale_, &from.scale_,
    static_cast<size_t>(reinterpret_cast<char*>(&brightness_) -
    reinterpret_cast<char*>(&scale_)) + sizeof(brightness_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEGlowSprite)
}

void CMsgTEGlowSprite::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&brightness_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(brightness_));
}

CMsgTEGlowSprite::~CMsgTEGlowSprite() {
  // @@protoc_insertion_point(destructor:CMsgTEGlowSprite)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEGlowSprite::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
}

void CMsgTEGlowSprite::ArenaDtor(void* object) {
  CMsgTEGlowSprite* _this = reinterpret_cast< CMsgTEGlowSprite* >(object);
  (void)_this;
}
void CMsgTEGlowSprite::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEGlowSprite::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEGlowSprite::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEGlowSprite)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(origin_ != nullptr);
    origin_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&brightness_) -
        reinterpret_cast<char*>(&scale_)) + sizeof(brightness_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEGlowSprite::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float scale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float life = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_life(&has_bits);
          life_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 brightness = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_brightness(&has_bits);
          brightness_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEGlowSprite::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEGlowSprite)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_scale(), target);
  }

  // optional float life = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_life(), target);
  }

  // optional uint32 brightness = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_brightness(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEGlowSprite)
  return target;
}

size_t CMsgTEGlowSprite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEGlowSprite)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional float scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float life = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 brightness = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_brightness());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEGlowSprite::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEGlowSprite)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEGlowSprite* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEGlowSprite>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEGlowSprite)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEGlowSprite)
    MergeFrom(*source);
  }
}

void CMsgTEGlowSprite::MergeFrom(const CMsgTEGlowSprite& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEGlowSprite)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      scale_ = from.scale_;
    }
    if (cached_has_bits & 0x00000004u) {
      life_ = from.life_;
    }
    if (cached_has_bits & 0x00000008u) {
      brightness_ = from.brightness_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEGlowSprite::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEGlowSprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEGlowSprite::CopyFrom(const CMsgTEGlowSprite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEGlowSprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEGlowSprite::IsInitialized() const {
  return true;
}

void CMsgTEGlowSprite::InternalSwap(CMsgTEGlowSprite* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, brightness_)
      + sizeof(CMsgTEGlowSprite::brightness_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEGlowSprite::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEImpact::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEImpact>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEImpact* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEImpact* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector&
CMsgTEImpact::_Internal::origin(const CMsgTEImpact* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTEImpact::_Internal::normal(const CMsgTEImpact* msg) {
  return *msg->normal_;
}
void CMsgTEImpact::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEImpact::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEImpact::CMsgTEImpact(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEImpact)
}
CMsgTEImpact::CMsgTEImpact(const CMsgTEImpact& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_normal()) {
    normal_ = new ::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:CMsgTEImpact)
}

void CMsgTEImpact::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(type_));
}

CMsgTEImpact::~CMsgTEImpact() {
  // @@protoc_insertion_point(destructor:CMsgTEImpact)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEImpact::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete normal_;
}

void CMsgTEImpact::ArenaDtor(void* object) {
  CMsgTEImpact* _this = reinterpret_cast< CMsgTEImpact* >(object);
  (void)_this;
}
void CMsgTEImpact::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEImpact::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEImpact::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEImpact)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
  }
  type_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEImpact::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEImpact::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEImpact)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::normal(this), target, stream);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEImpact)
  return target;
}

size_t CMsgTEImpact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEImpact)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEImpact::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEImpact)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEImpact* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEImpact>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEImpact)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEImpact)
    MergeFrom(*source);
  }
}

void CMsgTEImpact::MergeFrom(const CMsgTEImpact& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEImpact)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_normal()->::CMsgVector::MergeFrom(from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEImpact::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEImpact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEImpact::CopyFrom(const CMsgTEImpact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEImpact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEImpact::IsInitialized() const {
  return true;
}

void CMsgTEImpact::InternalSwap(CMsgTEImpact* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEImpact, type_)
      + sizeof(CMsgTEImpact::type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEImpact, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEImpact::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEMuzzleFlash::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEMuzzleFlash>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEMuzzleFlash* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEMuzzleFlash* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEMuzzleFlash::_Internal::origin(const CMsgTEMuzzleFlash* msg) {
  return *msg->origin_;
}
const ::CMsgQAngle&
CMsgTEMuzzleFlash::_Internal::angles(const CMsgTEMuzzleFlash* msg) {
  return *msg->angles_;
}
void CMsgTEMuzzleFlash::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEMuzzleFlash::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEMuzzleFlash)
}
CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(const CMsgTEMuzzleFlash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_angles()) {
    angles_ = new ::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  ::memcpy(&scale_, &from.scale_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&scale_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEMuzzleFlash)
}

void CMsgTEMuzzleFlash::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(type_));
}

CMsgTEMuzzleFlash::~CMsgTEMuzzleFlash() {
  // @@protoc_insertion_point(destructor:CMsgTEMuzzleFlash)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEMuzzleFlash::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete angles_;
}

void CMsgTEMuzzleFlash::ArenaDtor(void* object) {
  CMsgTEMuzzleFlash* _this = reinterpret_cast< CMsgTEMuzzleFlash* >(object);
  (void)_this;
}
void CMsgTEMuzzleFlash::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEMuzzleFlash::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEMuzzleFlash::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEMuzzleFlash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&scale_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEMuzzleFlash::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float scale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEMuzzleFlash::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEMuzzleFlash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::angles(this), target, stream);
  }

  // optional float scale = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_scale(), target);
  }

  // optional uint32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEMuzzleFlash)
  return target;
}

size_t CMsgTEMuzzleFlash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEMuzzleFlash)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional float scale = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEMuzzleFlash::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEMuzzleFlash)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEMuzzleFlash* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEMuzzleFlash>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEMuzzleFlash)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEMuzzleFlash)
    MergeFrom(*source);
  }
}

void CMsgTEMuzzleFlash::MergeFrom(const CMsgTEMuzzleFlash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEMuzzleFlash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_angles()->::CMsgQAngle::MergeFrom(from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      scale_ = from.scale_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEMuzzleFlash::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEMuzzleFlash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEMuzzleFlash::CopyFrom(const CMsgTEMuzzleFlash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEMuzzleFlash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEMuzzleFlash::IsInitialized() const {
  return true;
}

void CMsgTEMuzzleFlash::InternalSwap(CMsgTEMuzzleFlash* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, type_)
      + sizeof(CMsgTEMuzzleFlash::type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEMuzzleFlash::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEBloodStream::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBloodStream>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEBloodStream* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& direction(const CMsgTEBloodStream* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEBloodStream::_Internal::origin(const CMsgTEBloodStream* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTEBloodStream::_Internal::direction(const CMsgTEBloodStream* msg) {
  return *msg->direction_;
}
void CMsgTEBloodStream::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBloodStream::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEBloodStream::CMsgTEBloodStream(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBloodStream)
}
CMsgTEBloodStream::CMsgTEBloodStream(const CMsgTEBloodStream& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_direction()) {
    direction_ = new ::CMsgVector(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  ::memcpy(&color_, &from.color_,
    static_cast<size_t>(reinterpret_cast<char*>(&amount_) -
    reinterpret_cast<char*>(&color_)) + sizeof(amount_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBloodStream)
}

void CMsgTEBloodStream::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&amount_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(amount_));
}

CMsgTEBloodStream::~CMsgTEBloodStream() {
  // @@protoc_insertion_point(destructor:CMsgTEBloodStream)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEBloodStream::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete direction_;
}

void CMsgTEBloodStream::ArenaDtor(void* object) {
  CMsgTEBloodStream* _this = reinterpret_cast< CMsgTEBloodStream* >(object);
  (void)_this;
}
void CMsgTEBloodStream::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEBloodStream::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEBloodStream::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBloodStream)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&color_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&amount_) -
        reinterpret_cast<char*>(&color_)) + sizeof(amount_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBloodStream::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional fixed32 color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_color(&has_bits);
          color_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional uint32 amount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_amount(&has_bits);
          amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEBloodStream::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBloodStream)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgVector direction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::direction(this), target, stream);
  }

  // optional fixed32 color = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(3, this->_internal_color(), target);
  }

  // optional uint32 amount = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBloodStream)
  return target;
}

size_t CMsgTEBloodStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBloodStream)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector direction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional fixed32 color = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 amount = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_amount());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEBloodStream::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEBloodStream)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEBloodStream* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEBloodStream>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEBloodStream)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEBloodStream)
    MergeFrom(*source);
  }
}

void CMsgTEBloodStream::MergeFrom(const CMsgTEBloodStream& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBloodStream)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_direction()->::CMsgVector::MergeFrom(from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000008u) {
      amount_ = from.amount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEBloodStream::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEBloodStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEBloodStream::CopyFrom(const CMsgTEBloodStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBloodStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBloodStream::IsInitialized() const {
  return true;
}

void CMsgTEBloodStream::InternalSwap(CMsgTEBloodStream* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, amount_)
      + sizeof(CMsgTEBloodStream::amount_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBloodStream::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEExplosion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEExplosion>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEExplosion* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgVector& normal(const CMsgTEExplosion* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_materialtype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_affect_ragdolls(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_effect_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_explosion_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::CMsgVector&
CMsgTEExplosion::_Internal::origin(const CMsgTEExplosion* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTEExplosion::_Internal::normal(const CMsgTEExplosion* msg) {
  return *msg->normal_;
}
void CMsgTEExplosion::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEExplosion::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
CMsgTEExplosion::CMsgTEExplosion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEExplosion)
}
CMsgTEExplosion::CMsgTEExplosion(const CMsgTEExplosion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  effect_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_effect_name()) {
    effect_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_effect_name(), 
      GetArena());
  }
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_normal()) {
    normal_ = new ::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  ::memcpy(&framerate_, &from.framerate_,
    static_cast<size_t>(reinterpret_cast<char*>(&explosion_type_) -
    reinterpret_cast<char*>(&framerate_)) + sizeof(explosion_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEExplosion)
}

void CMsgTEExplosion::SharedCtor() {
effect_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&explosion_type_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(explosion_type_));
}

CMsgTEExplosion::~CMsgTEExplosion() {
  // @@protoc_insertion_point(destructor:CMsgTEExplosion)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEExplosion::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  effect_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete normal_;
}

void CMsgTEExplosion::ArenaDtor(void* object) {
  CMsgTEExplosion* _this = reinterpret_cast< CMsgTEExplosion* >(object);
  (void)_this;
}
void CMsgTEExplosion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEExplosion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEExplosion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEExplosion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      effect_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&framerate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&magnitude_) -
        reinterpret_cast<char*>(&framerate_)) + sizeof(magnitude_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&explosion_type_) -
        reinterpret_cast<char*>(&scale_)) + sizeof(explosion_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEExplosion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 framerate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_framerate(&has_bits);
          framerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 materialtype = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_materialtype(&has_bits);
          materialtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 radius = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 magnitude = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_magnitude(&has_bits);
          magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float scale = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool affect_ragdolls = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_affect_ragdolls(&has_bits);
          affect_ragdolls_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string effect_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_effect_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgTEExplosion.effect_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 explosion_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_explosion_type(&has_bits);
          explosion_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEExplosion::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEExplosion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional uint32 framerate = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_framerate(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional .CMsgVector normal = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::normal(this), target, stream);
  }

  // optional uint32 materialtype = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_materialtype(), target);
  }

  // optional uint32 radius = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_radius(), target);
  }

  // optional uint32 magnitude = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_magnitude(), target);
  }

  // optional float scale = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_scale(), target);
  }

  // optional bool affect_ragdolls = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_affect_ragdolls(), target);
  }

  // optional string effect_name = 10;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_effect_name().data(), static_cast<int>(this->_internal_effect_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTEExplosion.effect_name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_effect_name(), target);
  }

  // optional uint32 explosion_type = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_explosion_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEExplosion)
  return target;
}

size_t CMsgTEExplosion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEExplosion)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string effect_name = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_effect_name());
    }

    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector normal = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional uint32 framerate = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_framerate());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

    // optional uint32 materialtype = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_materialtype());
    }

    // optional uint32 radius = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_radius());
    }

    // optional uint32 magnitude = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_magnitude());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional float scale = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional bool affect_ragdolls = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional uint32 explosion_type = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_explosion_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEExplosion::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEExplosion)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEExplosion* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEExplosion>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEExplosion)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEExplosion)
    MergeFrom(*source);
  }
}

void CMsgTEExplosion::MergeFrom(const CMsgTEExplosion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEExplosion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_effect_name(from._internal_effect_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_normal()->::CMsgVector::MergeFrom(from._internal_normal());
    }
    if (cached_has_bits & 0x00000008u) {
      framerate_ = from.framerate_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      materialtype_ = from.materialtype_;
    }
    if (cached_has_bits & 0x00000040u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00000080u) {
      magnitude_ = from.magnitude_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      scale_ = from.scale_;
    }
    if (cached_has_bits & 0x00000200u) {
      affect_ragdolls_ = from.affect_ragdolls_;
    }
    if (cached_has_bits & 0x00000400u) {
      explosion_type_ = from.explosion_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEExplosion::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEExplosion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEExplosion::CopyFrom(const CMsgTEExplosion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEExplosion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEExplosion::IsInitialized() const {
  return true;
}

void CMsgTEExplosion::InternalSwap(CMsgTEExplosion* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  effect_name_.Swap(&other->effect_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, explosion_type_)
      + sizeof(CMsgTEExplosion::explosion_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEExplosion::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEDust::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEDust>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEDust* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgVector& direction(const CMsgTEDust* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTEDust::_Internal::origin(const CMsgTEDust* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTEDust::_Internal::direction(const CMsgTEDust* msg) {
  return *msg->direction_;
}
void CMsgTEDust::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDust::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEDust::CMsgTEDust(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEDust)
}
CMsgTEDust::CMsgTEDust(const CMsgTEDust& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_direction()) {
    direction_ = new ::CMsgVector(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  ::memcpy(&size_, &from.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&size_)) + sizeof(speed_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEDust)
}

void CMsgTEDust::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(speed_));
}

CMsgTEDust::~CMsgTEDust() {
  // @@protoc_insertion_point(destructor:CMsgTEDust)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEDust::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete direction_;
}

void CMsgTEDust::ArenaDtor(void* object) {
  CMsgTEDust* _this = reinterpret_cast< CMsgTEDust* >(object);
  (void)_this;
}
void CMsgTEDust::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEDust::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEDust::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEDust)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_) -
        reinterpret_cast<char*>(&size_)) + sizeof(speed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEDust::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_speed(&has_bits);
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEDust::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEDust)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional float size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_size(), target);
  }

  // optional float speed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_speed(), target);
  }

  // optional .CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::direction(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEDust)
  return target;
}

size_t CMsgTEDust::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEDust)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector direction = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional float size = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float speed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEDust::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEDust)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEDust* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEDust>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEDust)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEDust)
    MergeFrom(*source);
  }
}

void CMsgTEDust::MergeFrom(const CMsgTEDust& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEDust)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_direction()->::CMsgVector::MergeFrom(from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      speed_ = from.speed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEDust::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEDust)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEDust::CopyFrom(const CMsgTEDust& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEDust)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEDust::IsInitialized() const {
  return true;
}

void CMsgTEDust::InternalSwap(CMsgTEDust* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEDust, speed_)
      + sizeof(CMsgTEDust::speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEDust, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEDust::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTELargeFunnel::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTELargeFunnel>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTELargeFunnel* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reversed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTELargeFunnel::_Internal::origin(const CMsgTELargeFunnel* msg) {
  return *msg->origin_;
}
void CMsgTELargeFunnel::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
CMsgTELargeFunnel::CMsgTELargeFunnel(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTELargeFunnel)
}
CMsgTELargeFunnel::CMsgTELargeFunnel(const CMsgTELargeFunnel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  reversed_ = from.reversed_;
  // @@protoc_insertion_point(copy_constructor:CMsgTELargeFunnel)
}

void CMsgTELargeFunnel::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&reversed_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(reversed_));
}

CMsgTELargeFunnel::~CMsgTELargeFunnel() {
  // @@protoc_insertion_point(destructor:CMsgTELargeFunnel)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTELargeFunnel::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
}

void CMsgTELargeFunnel::ArenaDtor(void* object) {
  CMsgTELargeFunnel* _this = reinterpret_cast< CMsgTELargeFunnel* >(object);
  (void)_this;
}
void CMsgTELargeFunnel::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTELargeFunnel::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTELargeFunnel::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTELargeFunnel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(origin_ != nullptr);
    origin_->Clear();
  }
  reversed_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTELargeFunnel::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 reversed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_reversed(&has_bits);
          reversed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTELargeFunnel::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTELargeFunnel)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional uint32 reversed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_reversed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTELargeFunnel)
  return target;
}

size_t CMsgTELargeFunnel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTELargeFunnel)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional uint32 reversed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_reversed());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTELargeFunnel::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTELargeFunnel)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTELargeFunnel* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTELargeFunnel>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTELargeFunnel)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTELargeFunnel)
    MergeFrom(*source);
  }
}

void CMsgTELargeFunnel::MergeFrom(const CMsgTELargeFunnel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTELargeFunnel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      reversed_ = from.reversed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTELargeFunnel::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTELargeFunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTELargeFunnel::CopyFrom(const CMsgTELargeFunnel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTELargeFunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTELargeFunnel::IsInitialized() const {
  return true;
}

void CMsgTELargeFunnel::InternalSwap(CMsgTELargeFunnel* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, reversed_)
      + sizeof(CMsgTELargeFunnel::reversed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTELargeFunnel::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTESparks::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTESparks>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTESparks* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgVector& direction(const CMsgTESparks* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTESparks::_Internal::origin(const CMsgTESparks* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTESparks::_Internal::direction(const CMsgTESparks* msg) {
  return *msg->direction_;
}
void CMsgTESparks::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTESparks::clear_direction() {
  if (direction_ != nullptr) direction_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTESparks::CMsgTESparks(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTESparks)
}
CMsgTESparks::CMsgTESparks(const CMsgTESparks& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_direction()) {
    direction_ = new ::CMsgVector(*from.direction_);
  } else {
    direction_ = nullptr;
  }
  ::memcpy(&magnitude_, &from.magnitude_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&magnitude_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:CMsgTESparks)
}

void CMsgTESparks::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(length_));
}

CMsgTESparks::~CMsgTESparks() {
  // @@protoc_insertion_point(destructor:CMsgTESparks)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTESparks::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete direction_;
}

void CMsgTESparks::ArenaDtor(void* object) {
  CMsgTESparks* _this = reinterpret_cast< CMsgTESparks* >(object);
  (void)_this;
}
void CMsgTESparks::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTESparks::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTESparks::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTESparks)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(direction_ != nullptr);
      direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&magnitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&magnitude_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTESparks::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 magnitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_magnitude(&has_bits);
          magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTESparks::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTESparks)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional uint32 magnitude = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_magnitude(), target);
  }

  // optional uint32 length = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_length(), target);
  }

  // optional .CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::direction(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTESparks)
  return target;
}

size_t CMsgTESparks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTESparks)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector direction = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *direction_);
    }

    // optional uint32 magnitude = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_magnitude());
    }

    // optional uint32 length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTESparks::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTESparks)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTESparks* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTESparks>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTESparks)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTESparks)
    MergeFrom(*source);
  }
}

void CMsgTESparks::MergeFrom(const CMsgTESparks& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTESparks)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_direction()->::CMsgVector::MergeFrom(from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      magnitude_ = from.magnitude_;
    }
    if (cached_has_bits & 0x00000008u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTESparks::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTESparks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTESparks::CopyFrom(const CMsgTESparks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTESparks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTESparks::IsInitialized() const {
  return true;
}

void CMsgTESparks::InternalSwap(CMsgTESparks* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTESparks, length_)
      + sizeof(CMsgTESparks::length_)
      - PROTOBUF_FIELD_OFFSET(CMsgTESparks, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTESparks::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEPhysicsProp::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEPhysicsProp>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEPhysicsProp* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& velocity(const CMsgTEPhysicsProp* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEPhysicsProp* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_skin(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_effects(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_modelindex(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_unused_breakmodelsnottomake(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::CMsgVector&
CMsgTEPhysicsProp::_Internal::origin(const CMsgTEPhysicsProp* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTEPhysicsProp::_Internal::velocity(const CMsgTEPhysicsProp* msg) {
  return *msg->velocity_;
}
const ::CMsgQAngle&
CMsgTEPhysicsProp::_Internal::angles(const CMsgTEPhysicsProp* msg) {
  return *msg->angles_;
}
void CMsgTEPhysicsProp::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEPhysicsProp::clear_velocity() {
  if (velocity_ != nullptr) velocity_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void CMsgTEPhysicsProp::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
CMsgTEPhysicsProp::CMsgTEPhysicsProp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEPhysicsProp)
}
CMsgTEPhysicsProp::CMsgTEPhysicsProp(const CMsgTEPhysicsProp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_velocity()) {
    velocity_ = new ::CMsgVector(*from.velocity_);
  } else {
    velocity_ = nullptr;
  }
  if (from._internal_has_angles()) {
    angles_ = new ::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  ::memcpy(&skin_, &from.skin_,
    static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&skin_)) + sizeof(scale_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEPhysicsProp)
}

void CMsgTEPhysicsProp::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(scale_));
}

CMsgTEPhysicsProp::~CMsgTEPhysicsProp() {
  // @@protoc_insertion_point(destructor:CMsgTEPhysicsProp)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEPhysicsProp::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete velocity_;
  if (this != internal_default_instance()) delete angles_;
}

void CMsgTEPhysicsProp::ArenaDtor(void* object) {
  CMsgTEPhysicsProp* _this = reinterpret_cast< CMsgTEPhysicsProp* >(object);
  (void)_this;
}
void CMsgTEPhysicsProp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEPhysicsProp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEPhysicsProp::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEPhysicsProp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(velocity_ != nullptr);
      velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&skin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&modelindex_) -
        reinterpret_cast<char*>(&skin_)) + sizeof(modelindex_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&unused_breakmodelsnottomake_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scale_) -
        reinterpret_cast<char*>(&unused_breakmodelsnottomake_)) + sizeof(scale_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEPhysicsProp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional fixed32 skin = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_skin(&has_bits);
          skin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 effects = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_effects(&has_bits);
          effects_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional fixed32 color = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_color(&has_bits);
          color_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else goto handle_unusual;
        continue;
      // optional fixed64 modelindex = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_modelindex(&has_bits);
          modelindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else goto handle_unusual;
        continue;
      // optional uint32 unused_breakmodelsnottomake = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_unused_breakmodelsnottomake(&has_bits);
          unused_breakmodelsnottomake_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float scale = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEPhysicsProp::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEPhysicsProp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgVector velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::velocity(this), target, stream);
  }

  // optional .CMsgQAngle angles = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::angles(this), target, stream);
  }

  // optional fixed32 skin = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(4, this->_internal_skin(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  // optional uint32 effects = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_effects(), target);
  }

  // optional fixed32 color = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(7, this->_internal_color(), target);
  }

  // optional fixed64 modelindex = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(8, this->_internal_modelindex(), target);
  }

  // optional uint32 unused_breakmodelsnottomake = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_unused_breakmodelsnottomake(), target);
  }

  // optional float scale = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEPhysicsProp)
  return target;
}

size_t CMsgTEPhysicsProp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEPhysicsProp)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *velocity_);
    }

    // optional .CMsgQAngle angles = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional fixed32 skin = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

    // optional uint32 effects = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_effects());
    }

    // optional fixed32 color = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional fixed64 modelindex = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 unused_breakmodelsnottomake = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_unused_breakmodelsnottomake());
    }

    // optional float scale = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEPhysicsProp::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEPhysicsProp)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEPhysicsProp* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEPhysicsProp>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEPhysicsProp)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEPhysicsProp)
    MergeFrom(*source);
  }
}

void CMsgTEPhysicsProp::MergeFrom(const CMsgTEPhysicsProp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEPhysicsProp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_velocity()->::CMsgVector::MergeFrom(from._internal_velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_angles()->::CMsgQAngle::MergeFrom(from._internal_angles());
    }
    if (cached_has_bits & 0x00000008u) {
      skin_ = from.skin_;
    }
    if (cached_has_bits & 0x00000010u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      effects_ = from.effects_;
    }
    if (cached_has_bits & 0x00000040u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000080u) {
      modelindex_ = from.modelindex_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      unused_breakmodelsnottomake_ = from.unused_breakmodelsnottomake_;
    }
    if (cached_has_bits & 0x00000200u) {
      scale_ = from.scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEPhysicsProp::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEPhysicsProp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEPhysicsProp::CopyFrom(const CMsgTEPhysicsProp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEPhysicsProp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEPhysicsProp::IsInitialized() const {
  return true;
}

void CMsgTEPhysicsProp::InternalSwap(CMsgTEPhysicsProp* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, scale_)
      + sizeof(CMsgTEPhysicsProp::scale_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEPhysicsProp::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEPlayerDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEPlayerDecal>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEPlayerDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_player(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector&
CMsgTEPlayerDecal::_Internal::origin(const CMsgTEPlayerDecal* msg) {
  return *msg->origin_;
}
void CMsgTEPlayerDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
CMsgTEPlayerDecal::CMsgTEPlayerDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEPlayerDecal)
}
CMsgTEPlayerDecal::CMsgTEPlayerDecal(const CMsgTEPlayerDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  ::memcpy(&player_, &from.player_,
    static_cast<size_t>(reinterpret_cast<char*>(&entity_) -
    reinterpret_cast<char*>(&player_)) + sizeof(entity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEPlayerDecal)
}

void CMsgTEPlayerDecal::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&entity_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(entity_));
}

CMsgTEPlayerDecal::~CMsgTEPlayerDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEPlayerDecal)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEPlayerDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
}

void CMsgTEPlayerDecal::ArenaDtor(void* object) {
  CMsgTEPlayerDecal* _this = reinterpret_cast< CMsgTEPlayerDecal* >(object);
  (void)_this;
}
void CMsgTEPlayerDecal::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEPlayerDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEPlayerDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEPlayerDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(origin_ != nullptr);
    origin_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&player_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&entity_) -
        reinterpret_cast<char*>(&player_)) + sizeof(entity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEPlayerDecal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 player = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_player(&has_bits);
          player_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 entity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_entity(&has_bits);
          entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEPlayerDecal::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEPlayerDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional uint32 player = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_player(), target);
  }

  // optional uint32 entity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_entity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEPlayerDecal)
  return target;
}

size_t CMsgTEPlayerDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEPlayerDecal)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional uint32 player = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_player());
    }

    // optional uint32 entity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_entity());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEPlayerDecal::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEPlayerDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEPlayerDecal* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEPlayerDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEPlayerDecal)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEPlayerDecal)
    MergeFrom(*source);
  }
}

void CMsgTEPlayerDecal::MergeFrom(const CMsgTEPlayerDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEPlayerDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      player_ = from.player_;
    }
    if (cached_has_bits & 0x00000004u) {
      entity_ = from.entity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEPlayerDecal::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEPlayerDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEPlayerDecal::CopyFrom(const CMsgTEPlayerDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEPlayerDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEPlayerDecal::IsInitialized() const {
  return true;
}

void CMsgTEPlayerDecal::InternalSwap(CMsgTEPlayerDecal* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, entity_)
      + sizeof(CMsgTEPlayerDecal::entity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEPlayerDecal, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEPlayerDecal::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEProjectedDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEProjectedDecal>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEProjectedDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEProjectedDecal* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEProjectedDecal::_Internal::origin(const CMsgTEProjectedDecal* msg) {
  return *msg->origin_;
}
const ::CMsgQAngle&
CMsgTEProjectedDecal::_Internal::angles(const CMsgTEProjectedDecal* msg) {
  return *msg->angles_;
}
void CMsgTEProjectedDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEProjectedDecal::clear_angles() {
  if (angles_ != nullptr) angles_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEProjectedDecal::CMsgTEProjectedDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEProjectedDecal)
}
CMsgTEProjectedDecal::CMsgTEProjectedDecal(const CMsgTEProjectedDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_angles()) {
    angles_ = new ::CMsgQAngle(*from.angles_);
  } else {
    angles_ = nullptr;
  }
  ::memcpy(&index_, &from.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&index_)) + sizeof(distance_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEProjectedDecal)
}

void CMsgTEProjectedDecal::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(distance_));
}

CMsgTEProjectedDecal::~CMsgTEProjectedDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEProjectedDecal)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEProjectedDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete angles_;
}

void CMsgTEProjectedDecal::ArenaDtor(void* object) {
  CMsgTEProjectedDecal* _this = reinterpret_cast< CMsgTEProjectedDecal* >(object);
  (void)_this;
}
void CMsgTEProjectedDecal::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEProjectedDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEProjectedDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEProjectedDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(angles_ != nullptr);
      angles_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&distance_) -
        reinterpret_cast<char*>(&index_)) + sizeof(distance_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEProjectedDecal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float distance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_distance(&has_bits);
          distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEProjectedDecal::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEProjectedDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::angles(this), target, stream);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_index(), target);
  }

  // optional float distance = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEProjectedDecal)
  return target;
}

size_t CMsgTEProjectedDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEProjectedDecal)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *angles_);
    }

    // optional uint32 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_index());
    }

    // optional float distance = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEProjectedDecal::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEProjectedDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEProjectedDecal* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEProjectedDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEProjectedDecal)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEProjectedDecal)
    MergeFrom(*source);
  }
}

void CMsgTEProjectedDecal::MergeFrom(const CMsgTEProjectedDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEProjectedDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_angles()->::CMsgQAngle::MergeFrom(from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      distance_ = from.distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEProjectedDecal::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEProjectedDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEProjectedDecal::CopyFrom(const CMsgTEProjectedDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEProjectedDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEProjectedDecal::IsInitialized() const {
  return true;
}

void CMsgTEProjectedDecal::InternalSwap(CMsgTEProjectedDecal* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, distance_)
      + sizeof(CMsgTEProjectedDecal::distance_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEProjectedDecal::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTESmoke::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTESmoke>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTESmoke* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTESmoke::_Internal::origin(const CMsgTESmoke* msg) {
  return *msg->origin_;
}
void CMsgTESmoke::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
CMsgTESmoke::CMsgTESmoke(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTESmoke)
}
CMsgTESmoke::CMsgTESmoke(const CMsgTESmoke& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  scale_ = from.scale_;
  // @@protoc_insertion_point(copy_constructor:CMsgTESmoke)
}

void CMsgTESmoke::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scale_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(scale_));
}

CMsgTESmoke::~CMsgTESmoke() {
  // @@protoc_insertion_point(destructor:CMsgTESmoke)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTESmoke::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
}

void CMsgTESmoke::ArenaDtor(void* object) {
  CMsgTESmoke* _this = reinterpret_cast< CMsgTESmoke* >(object);
  (void)_this;
}
void CMsgTESmoke::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTESmoke::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTESmoke::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTESmoke)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(origin_ != nullptr);
    origin_->Clear();
  }
  scale_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTESmoke::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float scale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_scale(&has_bits);
          scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTESmoke::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTESmoke)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTESmoke)
  return target;
}

size_t CMsgTESmoke::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTESmoke)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional float scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTESmoke::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTESmoke)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTESmoke* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTESmoke>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTESmoke)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTESmoke)
    MergeFrom(*source);
  }
}

void CMsgTESmoke::MergeFrom(const CMsgTESmoke& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTESmoke)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      scale_ = from.scale_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTESmoke::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTESmoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTESmoke::CopyFrom(const CMsgTESmoke& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTESmoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTESmoke::IsInitialized() const {
  return true;
}

void CMsgTESmoke::InternalSwap(CMsgTESmoke* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTESmoke, scale_)
      + sizeof(CMsgTESmoke::scale_)
      - PROTOBUF_FIELD_OFFSET(CMsgTESmoke, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTESmoke::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

class CMsgTEWorldDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEWorldDecal>()._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEWorldDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEWorldDecal* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector&
CMsgTEWorldDecal::_Internal::origin(const CMsgTEWorldDecal* msg) {
  return *msg->origin_;
}
const ::CMsgVector&
CMsgTEWorldDecal::_Internal::normal(const CMsgTEWorldDecal* msg) {
  return *msg->normal_;
}
void CMsgTEWorldDecal::clear_origin() {
  if (origin_ != nullptr) origin_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CMsgTEWorldDecal::clear_normal() {
  if (normal_ != nullptr) normal_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
CMsgTEWorldDecal::CMsgTEWorldDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:CMsgTEWorldDecal)
}
CMsgTEWorldDecal::CMsgTEWorldDecal(const CMsgTEWorldDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    origin_ = new ::CMsgVector(*from.origin_);
  } else {
    origin_ = nullptr;
  }
  if (from._internal_has_normal()) {
    normal_ = new ::CMsgVector(*from.normal_);
  } else {
    normal_ = nullptr;
  }
  index_ = from.index_;
  // @@protoc_insertion_point(copy_constructor:CMsgTEWorldDecal)
}

void CMsgTEWorldDecal::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&origin_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&index_) -
    reinterpret_cast<char*>(&origin_)) + sizeof(index_));
}

CMsgTEWorldDecal::~CMsgTEWorldDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEWorldDecal)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CMsgTEWorldDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete origin_;
  if (this != internal_default_instance()) delete normal_;
}

void CMsgTEWorldDecal::ArenaDtor(void* object) {
  CMsgTEWorldDecal* _this = reinterpret_cast< CMsgTEWorldDecal* >(object);
  (void)_this;
}
void CMsgTEWorldDecal::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgTEWorldDecal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgTEWorldDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEWorldDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(origin_ != nullptr);
      origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(normal_ != nullptr);
      normal_->Clear();
    }
  }
  index_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEWorldDecal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsgTEWorldDecal::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEWorldDecal)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::origin(this), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::normal(this), target, stream);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEWorldDecal)
  return target;
}

size_t CMsgTEWorldDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEWorldDecal)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *normal_);
    }

    // optional uint32 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CMsgTEWorldDecal::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:CMsgTEWorldDecal)
  GOOGLE_DCHECK_NE(&from, this);
  const CMsgTEWorldDecal* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CMsgTEWorldDecal>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:CMsgTEWorldDecal)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:CMsgTEWorldDecal)
    MergeFrom(*source);
  }
}

void CMsgTEWorldDecal::MergeFrom(const CMsgTEWorldDecal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEWorldDecal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_origin()->::CMsgVector::MergeFrom(from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_normal()->::CMsgVector::MergeFrom(from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      index_ = from.index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CMsgTEWorldDecal::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:CMsgTEWorldDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CMsgTEWorldDecal::CopyFrom(const CMsgTEWorldDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEWorldDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEWorldDecal::IsInitialized() const {
  return true;
}

void CMsgTEWorldDecal::InternalSwap(CMsgTEWorldDecal* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, index_)
      + sizeof(CMsgTEWorldDecal::index_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, origin_)>(
          reinterpret_cast<char*>(&origin_),
          reinterpret_cast<char*>(&other->origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEWorldDecal::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgTEArmorRicochet* Arena::CreateMaybeMessage< ::CMsgTEArmorRicochet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEArmorRicochet >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBaseBeam* Arena::CreateMaybeMessage< ::CMsgTEBaseBeam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBaseBeam >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBeamEntPoint* Arena::CreateMaybeMessage< ::CMsgTEBeamEntPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBeamEntPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBeamEnts* Arena::CreateMaybeMessage< ::CMsgTEBeamEnts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBeamEnts >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBeamPoints* Arena::CreateMaybeMessage< ::CMsgTEBeamPoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBeamPoints >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBeamRing* Arena::CreateMaybeMessage< ::CMsgTEBeamRing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBeamRing >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBSPDecal* Arena::CreateMaybeMessage< ::CMsgTEBSPDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBSPDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBubbles* Arena::CreateMaybeMessage< ::CMsgTEBubbles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBubbles >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBubbleTrail* Arena::CreateMaybeMessage< ::CMsgTEBubbleTrail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBubbleTrail >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEDecal* Arena::CreateMaybeMessage< ::CMsgTEDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgEffectData* Arena::CreateMaybeMessage< ::CMsgEffectData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgEffectData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEEffectDispatch* Arena::CreateMaybeMessage< ::CMsgTEEffectDispatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEEffectDispatch >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEEnergySplash* Arena::CreateMaybeMessage< ::CMsgTEEnergySplash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEEnergySplash >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEFizz* Arena::CreateMaybeMessage< ::CMsgTEFizz >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEFizz >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEShatterSurface* Arena::CreateMaybeMessage< ::CMsgTEShatterSurface >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEShatterSurface >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEGlowSprite* Arena::CreateMaybeMessage< ::CMsgTEGlowSprite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEGlowSprite >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEImpact* Arena::CreateMaybeMessage< ::CMsgTEImpact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEImpact >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEMuzzleFlash* Arena::CreateMaybeMessage< ::CMsgTEMuzzleFlash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEMuzzleFlash >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBloodStream* Arena::CreateMaybeMessage< ::CMsgTEBloodStream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBloodStream >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEExplosion* Arena::CreateMaybeMessage< ::CMsgTEExplosion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEExplosion >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEDust* Arena::CreateMaybeMessage< ::CMsgTEDust >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEDust >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTELargeFunnel* Arena::CreateMaybeMessage< ::CMsgTELargeFunnel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTELargeFunnel >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTESparks* Arena::CreateMaybeMessage< ::CMsgTESparks >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTESparks >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEPhysicsProp* Arena::CreateMaybeMessage< ::CMsgTEPhysicsProp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEPhysicsProp >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEPlayerDecal* Arena::CreateMaybeMessage< ::CMsgTEPlayerDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEPlayerDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEProjectedDecal* Arena::CreateMaybeMessage< ::CMsgTEProjectedDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEProjectedDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTESmoke* Arena::CreateMaybeMessage< ::CMsgTESmoke >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTESmoke >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEWorldDecal* Arena::CreateMaybeMessage< ::CMsgTEWorldDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEWorldDecal >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
